
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8" />
  <title>RML: A Generic Mapping Language for RDF</title>
  <meta name=v"" content=  "" />
  <!-- <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css" /> -->
  <style type="text/css">
/*<![CDATA[*/
        body {
          padding: 2em 1em 2em 70px;
          margin: 0;
          font-family: sans-serif;
          color: black;
          background: white;
          background-position: top left;
          background-attachment: fixed;
          background-repeat: no-repeat;
        }

        h1, h2, h3, h4, h5, h6 { text-align: left }
        /* background should be transparent, but WebTV has a bug */
        h1, h2, h3 { color: #005A9C; background: white }
        h1 { font: 170% sans-serif }
        h2 { font: 140% sans-serif }
        h3 { font: 120% sans-serif }
        h4 { font: bold 100% sans-serif }
        h5 { font: italic 100% sans-serif }
        h6 { font: small-caps 100% sans-serif }

        dfn { color: navy; font-weight: bold; }
        pre { margin-left: 0; padding: 0 2em; }
        dt { margin-top: 0.8em; }
        th, td { padding: 0.3em 0.5em; }
        cite { font-style: normal }
        th { text-align: left; }
        h2, h3 { margin-top: 2em; }
        em.rfc2119 { text-transform: lowercase; font-variant: small-caps; font-style: normal; }
        
        table.term-index th code { font-weight: normal; }
        table.term-index th, table.term-index td { padding: 0.1em 0.5em; }
        .issue { background-color: #fdd; border: 1px solid #800; margin: 1em 0em; padding: 1em; page-break-inside: avoid ; font-style: italic; }
        .issue a.tracker { font-style: normal; font-weight: bold; }
        .note { background: #e2fff0; border: 2px solid #cff6d9; margin: 1em 0em 0em; padding: 1em; }
        .note:before { background: #fff; border: 1px solid #cff6d9; content: "Note"; display: block; font-weight: bold; margin: -1.5em 0 0.5em 0; padding: 0.2em 0.8em; width: 2.5em; }
        .ex-data, table.ex-data th, table.ex-data td { background: #cee; border: 1px solid #acc; }
        table.ex-data { border-collapse: collapse; margin-bottom: 1.5em; }
        table.ex-data caption, table.ex-data th, table.ex-data td { font-family: monospace; }
        table.ex-data caption, table.ex-data th { font-size: 125%; }
        table.ex-data caption { font-weight: bold; }
        table.ex-data th small, table.ex-data caption small { display: block; font-size: 65%; font-weight: normal; }
        pre.vocab, pre.ex-mapping, pre.ex-output, pre.ex-sql { margin-top: 1.5em; padding: 1em; }
        pre.vocab:before, pre.ex-mapping:before, pre.ex-output:before, pre.ex-sql:before { background: white; display: block; font-family: sans-serif; font-size: 90%; margin: -1.7em 0 0.5em 0; padding: 0.2em 0.4em; }
        pre.vocab { background: #d4dddd; }
        pre.vocab, pre.vocab:before { border: 1px solid #bbb; }
        pre.vocab:before { color: #888; content: "RML vocabulary definition"; width: 13em; }
        pre.ex-mapping, pre.ex-sql { background: #eeb; }
        pre.ex-mapping, pre.ex-mapping:before, pre.ex-sql, pre.ex-sql:before { border: 1px solid #cc9; }
        pre.ex-mapping:before { color: #996; content: "Example RML mapping"; width: 12em; }
        pre.ex-sql:before { color: #996; content: "Example query"; width: 9em; }
        .ex-output { background: #cfc; }
        .ex-output, .ex-output:before, .ex-output th, .ex-output td { border: 1px solid #aca; }
        pre.ex-output:before { color: #797; content: "Example output data"; width: 9.5em; }
        .toc ul { list-style-type: none; }
        .toc > li { font-weight: bold; margin-bottom: 0.8em; }
        .toc li li { font-weight: normal; }
  /*]]>*/
  </style>
</head>

<body>
  <div class="head">

    <h1><a name="title" id="title"></a>RML: A Generic Mapping Language for RDF</h1>

    <dl>
      <dt>This version:</dt> 
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd> 

      <dt>Latest version:</dt>
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd>

      <dt>Previous version:</dt>
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd>

      <dt>Editors:</dt>
      <dd>Anastasia Dimou</dd>
      <dd>Miel Vander Sande</dd>
    </dl>

    <p class="copyright"><a href="">Copyright</a> &copy; 2013 <sup>&reg;</sup>
  </div>
  <hr />


  <h2><a name="abstract" id="abstract"></a>Abstract</h2>

  <p>This document describes RML, a generic mapping language, based on and extending R2RML.
     R2RML is the W3C standard to express customized mappings from relational databases to RDF.
     RML extends R2RML to support data in other structured formats, too. 
     RML is a lnaguage for expressing customized mappings from data in structured formats to RDF datasets. 
     Such mappings provide the ability to view existing data in the RDF data model described using the mapping author's choice of vocabulary. 
     RML follows exactly the same syntax as R2RML; therefore, RML mappings are themselves RDF graphs and written down in Turtle syntax. 
  </p>

  
  <div class="toc">
    <h2><a name="contents" id="contents"></a>Table of Contents</h2>

<ul class="toc">
  <li><a href="#introduction">1 Introduction</a>
  <ul>
    <li><a href="#conventions">1.1 Document Conventions</a></li>
  </ul></li>
  <li><a href="#overview">2 R2RML Overview and Example (Informative)</a>
  <li><a href="#terminology">A. RDF Terminology (Informative)</a></li>
  <li><a href="#index">B. Index of R2RML Vocabulary Terms (Informative)</a>
  <ul>
    <li><a href="#class-index">B.1 Classes</a></li>
    <li><a href="#property-index">B.2 Properties</a></li>
    <li><a href="#other-index">B.3 Other Terms</a></li>
  </ul></li>
  <li><a href="#references">C. References</a>
  <ul>
    <li><a href="#normative-refs">C.1 Normative References</a></li>
    <li><a href="#non-normative-refs">C.2 Other References</a></li>
  </ul></li>
  <li><a href="#acknowledgements">D. Acknowledgements (Informative)</a></li>
</ul>

</div>

  <hr />

  <div class="body">
    <h2><a name="introduction" id="introduction"></a>1 Introduction</h2>

    <p>This specification describes RML, a language for expressing customized mappings
    from data in structured formats (databases and CSV, TSV, XML and JSON files) to RDF datasets. 
    Such mappings describe how existing data can be represented using the RDF data model.</p>

    <p>RML is based on and extends <cite>
      <a class="norm" href="http://www.w3.org/TR/r2rml/">R2RML</a></cite> [<cite><a href="#R2RML">R2RML</a></cite>].
    R2RML is defined to express customized mappings only from relational databases to RDF datasets. </p>

    <p>An RML mapping is not tailored to a specific database schema, as an R2RML mapping, but can be defined for data in any other data format. 
      The input to an RML mapping can be any source file - currently in a structured format or a database. 
      The output is an RDF dataset that uses predicates and types from the target vocabulary. </p>

    <p>RML follow the same syntax as R2RML; therefore they are expressed as RDF graphs and written down in
    <cite><a class="norm" href="http://www.w3.org/TR/turtle/">Turtle syntax</a></cite> [<cite><a href="#TURTLE">TURTLE</a></cite>].</p>

    <h3 id="vocabulary">4.1 Mapping Graphs and the R2RML Vocabulary</h3>
    <p>The RML vocabulary namespace is <code>http://mmlab.be/ns/rml#</code> 
      <pre><strong><a href="http://www.w3.org/ns/r2rml#">http://mmlab.be/ns/rml#</a></strong></pre>
    </p>
    <p>The RML vocabulary preferred prefix is the <code>rml:</code> </p>

    <p>An RML mapping defines a mapping from any data in a structured source format to RDF. 
      It consists of one or more triples maps</a>.</p>

    <p>The input to an R2RML mapping is called source file.</p>

    <p>The RML vocabulary consists of the RML specific defined classes but also includes all the R2RML classes</p>

    <ul>
      <li><code>rr:TriplesMap</code> is the class of triples maps as defined by R2RML.</li>
      <li><code>rml:LogicalSource</code> is the class of logical sources. 
        It has two subclasses:
        <ul>
          <li><code>rml:RMLView</code> is the class of RML views</a>. R2RML's <code>rr:R2RMLView</code> is a subclass of <code>rml:RMLView</code></li>
          <li><code>rml:BaseSource</code> is the class of SQL base tables or views</a>. R2RML's <code>rr:BaseTableOrView</code> is a subclass of <code>rml:BaseSource</code></li>
        </ul>
      </li>
      <li><code>rr:TermMap</code> is the class of term maps, as defined by R2RML. 
        It has four subclasses:
        <ul>
          <li><code>rr:SubjectMap</code> is the class of subject maps.</li>
          <li><code>rr:PredicateMap</code> is the class of predicate maps.</li>
          <li><code>rr:ObjectMap</code> is the class of object maps.</li>
          <li><code>rr:GraphMap</code> is the class of graph maps.</li>
        </ul>
      </li>
      <li><code>rr:PredicateObjectMap</code> is the class of predicate-object maps.</li>
      <li><code>rr:RefObjectMap</code> is the class of referencing object maps.</li>
      <li><code>rr:Join</code> is the class of join conditions.</li>
      <li><code>rml:QueryLanguage</code> is the class of supported query languages.</li>
    </ul>

    <h3 id="conventions">Document Conventions</h3>

    <p>In this document, examples assume the following namespace prefix bindings unless otherwise stated:</p>

    <table rules="all" summary="list of prefixes used in the document">
      <tr>
        <th>Prefix</th>

        <th>IRI</th>
      </tr>

      <tr>
        <td><code>rml:</code></td>

        <td><code>http://mmlab.be/ns/rml#</code></td>
      </tr>

      <tr>
        <td><code>ql:</code></td>

        <td><code>http://mmlab.be/ns/ql#</code></td>
      </tr>

      <tr>
        <td><code>rr:</code></td>

        <td><code>http://www.w3.org/ns/r2rml#</code></td>
      </tr>

      <tr>
        <td><code>rdf:</code></td>

        <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
      </tr>

      <tr>
        <td><code>rdfs:</code></td>

        <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
      </tr>

      <tr>
        <td><code>xsd:</code></td>

        <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
      </tr>

      <tr>
        <td><code>ex:</code></td>

        <td><code>http://example.com/ns#</code></td>
      </tr>
    </table>

    <p>Gray boxes contain RDFS definitions of RML vocabulary terms:</p>
    <pre class="vocab">
      # This box contains RDFS definitions of RML vocabulary terms
    </pre>

    <p>Yellow boxes contain example fragments of RML mappings in Turtle syntax:</p>
    <pre class="ex-mapping">
      # This box contains example RML mappings
    </pre>

    <p>Blue tables contain example input into an RML mapping:</p>
    <table class="ex-data">
        <caption>input</caption>
        <tr>
          <td>
            #This box contains example input
          </d>
        </tr>
      </table>

    <p>Green boxes contain example output:</p>
    <pre class="ex-output">
      # This box contains example output RDF triples or fragments
    </pre>


    <h2 id="overview">RML Overview and Example (Informative)</h2>

    <p>An RML mapping refers to logical sources to retrieve data from the input file or database. 
      A logical source extends R2RML's logical Table. A logical source can be one of the following:</p>
    <ol>
      <li>A base source (A/N any input file or base table),</li>
      <li>a view (A/N in case of databases), or</li>
      <li>a valid query (called an RML view).</li>
    </ol>

    <h3 id="example-input-database">Example Input</h3>

    <table class="ex-data" id="">
        <caption>Airport.csv - CSV file</caption>
        <tr>
          <td>
            id, city, bus, latitude, longitude <br/>
            6523, Brussels, 25, 50.901389, 4.484444
          </d>
        </tr>
      </table>

      <table class="ex-data">
        <caption>Transport.xml - XML file</caption>
        <tr>
          <td>
            <span>
              &#60;transport&#62; <br/>
              &nbsp; &#60;bus id=“25”&#62; <br/>
              &nbsp; &nbsp; &#60;route&#62; <br/>
              &nbsp; &nbsp; &nbsp; &#60;stop id=“645”&#62; <br/>
              &nbsp; &nbsp; &nbsp; &nbsp; Int. Airport <br/>
              &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
              &nbsp; &nbsp; &nbsp; &#60;stop id=“651”&#62; <br/>
              &nbsp; &nbsp; &nbsp; &nbsp; Conference center <br/>
              &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
              &nbsp; &nbsp; &#60;/route&#62; <br/>
              &nbsp; &#60;/bus&#62; <br/>
              &#60;/transport&#62;
            </span>
          </d>
        </tr>
      </table>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP">
        <caption>Venue.json - JSON file</caption>
        <tr>
          <td>
            <span>
              { <br/>
                &nbsp; "venue": <br/>
                &nbsp; &nbsp; { <br/>
                &nbsp; &nbsp; &nbsp; "latitude": "51.0500000", <br/>
                &nbsp; &nbsp; &nbsp; "longitude": "3.7166700" <br/>
                &nbsp; &nbsp; }, <br/>
                &nbsp; &nbsp; "location": <br/>
                &nbsp; &nbsp; &nbsp; { <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "continent": "EU", <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "country": "BE", <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "city": "Brussels" <br/>
                &nbsp; &nbsp; &nbsp; } <br/>
                }     
            </span>
          </d>
        </tr>
      </table>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#AirportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName “http://www.example.com/Airport.csv”
            ];
            rr:subjectMap 
            [
              rr:template “http://airport.example.com/{id}”;
              rr:class transit:Stop 
            ];

          rr:predicateObjectMap 
          [
            rr:predicate transit:route;
            rr:objectMap 
            [ 
              &lt;#TransportMapping&gt;
                rr:joinCondition 
                [
                  rr:child “bus”;
                  rr:parent “/transport/bus@id” 
                ]
            ]
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:location;
            rr:objectMap 
            [ 
              &lt;#VenueMapping&gt;
              rr:joinCondition 
              [
                rr:child “city”;
                rr:parent “$.location.city”
              ]
            ]
          ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#TransportMapping&gt;
          rr:subjectMap 
          [ 
            rr:template “http://trans.example.com/{/transport/bus@id}”;
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector “/transport/bus/route/stop@id”;
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector “/transport/bus/route/stop”
            ]
          ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#LocationMapping&gt;
          rr:subjectMap 
          [
            rr:template http://loc.example.com/latlong/{$.venue.latitude},{$.venue.longitude}
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap “$.venue.latitude” 
          ]; 

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap “$.venue.longitude” 
          ] 
        ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#VenueMapping&gt;
          rml:logicalSource 
          [
            rml:name “http://www.example.com/Venue.json”;
            rml:language ql:JSONPath 
          ];
          rr:subjectMap 
          [
            rr:template “http://loc.example.com/city/{$.location.city}”;
            rr:class schema:City;
          ];
          rr:predicateObjectMap 
          [
            rr:predicate geo:location;
            rr:objectMap &lt;#LocationMapping&gt; 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate gn:countryCode;
            rr:objectMap “$.location.country” 
          ]
          rr:predicateObjectMap 
          [
            rr:predicate geosp:onContinent;
            rr:objectMap “$.location.continent” 
          ].
      </pre>

    <p>The desired RDF triples to be produced from this database are as follows:</p>

    <pre class="ex-output">
      for Venue.json <br/>
        &lt;http://loc.example.com/city/Brussels&gt; geo:location &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt;.
        &lt;http://loc.example.com/city/Brussels&gt; gn:countryCode "BE".
        &lt;http://loc.example.com/city/Brussels&gt; geosp:onContinent "Europe".

        &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt; wgs84_pos:lat "51.0500000".
        &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt; wgs84_pos:long "3.7166700".
    </pre>

    <h3 id="example-simple">Example: Mapping a CSV file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding CSV file. 
      RML mappings for CSV files follow exactly the same syntax as in R2RML to refer to the CSV's records.
      It is considered a correspondence of CSV records, delimited by a line break (CRLF), to databases' rows.</p>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP">
        <caption>Airport.csv - CSV file</caption>
        <tr>
          <td>
            id, stop, latitude, longitude <br/>
            6523, 25, 50.901389, 4.484444
          </d>
        </tr>
      </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.

        &lt;#AirportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Airport.csv"
            ];
          rr:subjectMap 
            [
              rr:template "http://airport.example.com/{id}";
              rr:class transit:Stop 
            ];

          rr:predicateObjectMap 
          [
            rr:predicate transit:route;
            rr:objectMap 
            [
              rml:selector "stop";
              rr:datatype xsd:int 
            ]
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap "latitude" 
          ];
            
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap "longitude" 
          ].
      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#&gt;.
      <br/>
      &lt;http://airport.example.com/6523&gt; rdf:type transit:Stop.
      &lt;http://airport.example.com/6523&gt; transit:route "25"^^xsd:int.
      &lt;http://airport.example.com/6523&gt; wgs84_pos:lat "50.901389".
      &lt;http://airport.example.com/6523&gt; wgs84_pos:long "4.484444".
    </pre>


    <h3 id="example-r2rml-view">Example: Mapping an XML file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding XML file. 
      RML mappings for XML files follow the same syntax as in R2RML.
      The references to the XML elements follow the syntax of the query language specified at the logical source.
      A/N XPath is the preferred/supported query language for XML files. 
    </p>

    <table class="ex-data">
      <caption>Transport.xml - XML file</caption>
      <tr>
        <td>
          <span>
            &#60;transport&#62; <br/>
            &nbsp; &#60;bus id=“25”&#62; <br/>
            &nbsp; &nbsp; &#60;route&#62; <br/>
            &nbsp; &nbsp; &nbsp; &#60;stop id=“645”&#62; <br/>
            &nbsp; &nbsp; &nbsp; &nbsp; International Airport <br/>
            &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
            &nbsp; &nbsp; &nbsp; &#60;stop id=“651”&#62; <br/>
            &nbsp; &nbsp; &nbsp; &nbsp; Conference center <br/>
            &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
            &nbsp; &nbsp; &#60;/route&#62; <br/>
            &nbsp; &#60;/bus&#62; <br/>
            &#60;/transport&#62;
          </span>
        </d>
      </tr>
    </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

        &lt;#TransportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Transport.xml" ;
              rml:query "transport/bus";
              rml:language ql:XPath;
            ];
          rr:subjectMap 
          [ 
            rr:template "http://trans.example.com/{/transport/bus@id}";
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop@id";
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop"
            ]
          ].
      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

      &lt;http://trans.example.com/25&gt; rdf:type transit:Stop.
      &lt;http://trans.example.com/25&gt; transit:stop "645"^^xsd:int.
      &lt;http://trans.example.com/25&gt; rdfs:label "International Airport".
      &lt;http://trans.example.com/25&gt; transit:stop "651"^^xsd:int.
      &lt;http://trans.example.com/25&gt; rdfs:label "Conference center".
    </pre>

    <h3 id="example-r2rml-view">Example: Mapping a JSON file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding JSON file. 
      RML mappings for JSON files follow the same syntax as in R2RML.
      The references to the JSON objects follow the syntax of the query language specified at the logical source.
      A/N JSONPath is the preferred/supported query language for JSON files. 
    </p>

    <table class="ex-data">
      <caption>Venue.json - JSON file</caption>
      <tr>
        <td>
          <span>
              { <br/>
              &nbsp; "venue": <br/>
              &nbsp; { <br/>
              &nbsp; &nbsp; "latitude": "51.0500000", <br/>
              &nbsp; &nbsp; "longitude": "3.7166700" <br/>
              &nbsp; }, <br/>
              &nbsp; "location": <br/>
              &nbsp; { <br/>
              &nbsp; &nbsp; "continent": " EU", <br/>
              &nbsp; &nbsp; "country": "BE", <br/>
              &nbsp; &nbsp; "city": "Brussels" <br/>
              &nbsp;} <br/>
              } <br/>

          </span>
        </d>
      </tr>
    </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix schema: &lt;http://schema.org/&gt;.
        @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.
        @prefix gn: &lt;http://www.geonames.org/ontology#&gt;.

        &lt;#VenueMapping&gt;
          rml:logicalSource [
            rml:sourceName "http://www.example.com/files/Venue.json";
            rml:queryLanguage ql:JSONPath;
            rml:query "$"
          ];
          rr:subjectMap [
            rr:template "http://loc.example.com/city/{$.location.city}";
            rr:class schema:City 
          ];
    
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap "latitude" 
          ];
            
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap "longitude" 
          ];

          rr:predicateObjectMap [
            rr:predicate gn:countryCode;
            rr:objectMap "$.location.country" 
          ].

      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix schema: &lt;http://schema.org/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
      @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.
      @prefix gn: &lt;http://www.geonames.org/ontology#&gt;.

      &lt;http://loc.example.com/city/25&gt; rdf:type schema:City.
      &lt;http://loc.example.com/city/25&gt; wgs84_pos:lat "50.901389".
      &lt;http://loc.example.com/city/25&gt; wgs84_pos:long "4.484444".
      &lt;http://loc.example.com/city/25&gt; gn:countryCode "BE".
    </pre>


    <h3 id="">Linking Two Files</h3>

    <p>
      To have more complete mappings, triples with the city where the airport is located needs to be generated.   
      Those triples' subject come from the <code>&lt;#AirportMapping&gt;</code> triples map, 
      while the objects come from the <code>&lt;#VenueMapping&gt;</code>.
    </p>

    <p>This can be achieved by adding another <code>rr:predicateObjectMap</code>
    to the <code>&lt;#AirportMapping&gt;</code>. This one uses the other triples map,
    <code>&lt;#VenueMapping&gt;</code>, as a parent triples map:</p>

    <pre class="ex-mapping">&lt;#AirportMapping&gt;
        rr:predicateObjectMap [
            rr:predicate ex:located;
            rr:objectMap [
                rr:parentTriplesMap &lt;#VenueMapping&gt;;
                rr:joinCondition [
                    rr:child "DEPTNO";
                    rr:parent "DEPTNO";
                ];
            ];
        ].</pre>

    <p>This performs a union between the CSV file and the JSON file. The objects will be generated from
    the subject map of the parent triples map, yielding the desired triple:</p>

    <pre class="ex-output">
      &lt;http://data.example.com/employee/7369&gt; ex:located &lt;http://data.example.com/department/10&gt;.
    </pre>

    <p>
      This completes the RML mapping document. An RML processor will generate the triples listed above from this mapping document.
    </p>


    <!-- <h3 id="">Many-to-Many Files</h3>

    <p>The following example will assume that a many-to-many relationship exists between 
    the extended versions of <a href="#ex_EMP_m2m"><code>EMP</code> table</a> and the <a
    href="#ex_DEPT_m2m"><code>DEPT</code> table</a> shown below. This
    many-to-many relationship is captured by the content of
    the <a href="#ex_EMP2DEPT"><code>EMP2DEPT</code> table</a>. The database consisting of
    the <code>EMP</code>, <code>DEPT</code>, and <code>EMP2DEPT</code> tables are shown below:</p>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP_m2m">
        <caption>EMP</caption>
        <tr>
          <th>EMPNO <small>INTEGER PRIMARY KEY</small></th>
          <th>ENAME <small>VARCHAR(100)</small></th>
          <th>JOB <small>VARCHAR(20)</small></th>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>SMITH</code></td>
          <td><code>CLERK</code></td>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>SMITH</code></td>
          <td><code>NIGHTGUARD</code></td>
        </tr>
        <tr>
          <td><code>7400</code></td>
          <td><code>JONES</code></td>
          <td><code>ENGINEER</code></td>
        </tr>

      </table>

      <table class="ex-data" summary="DEPT table: sample data" id="ex_DEPT_m2m">
        <caption>DEPT</caption>
        <tr>
          <th>DEPTNO <small>INTEGER PRIMARY KEY</small></th>
          <th>DNAME <small>VARCHAR(30)</small></th>
          <th>LOC <small>VARCHAR(100)</small></th>
        </tr>
        <tr>
          <td><code>10</code></td>
          <td><code>APPSERVER</code></td>
          <td><code>NEW YORK</code></td>
        </tr>
        <tr>
          <td><code>20</code></td>
          <td><code>RESEARCH</code></td>
          <td><code>BOSTON</code></td>
        </tr>
      </table>

      <table class="ex-data" summary="EMP2DEPT table: sample data" id="ex_EMP2DEPT">
        <caption>EMP2DEPT <small>PRIMARY KEY (EMPNO, DEPTNO)</small></caption>
        <tr>
          <th>EMPNO <small>INTEGER REFERENCES EMP (EMPNO)</small></th>
          <th>DEPTNO <small>INTEGER REFERENCES DEPT (DEPTNO)</small></th>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>10</code></td>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>20</code></td>
        </tr>
        <tr>
          <td><code>7400</code></td>
          <td><code>10</code></td>
        </tr>
      </table>

    <pre class="ex-output">
&lt;http://data.example.com/employee=7369/department=10&gt; 
    ex:employee   &lt;http://data.example.com/employee/7369&gt; ;
    ex:department &lt;http://data.example.com/department/10&gt; .

&lt;http://data.example.com/employee=7369/department=20&gt; 
    ex:employee &lt;http://data.example.com/employee/7369&gt; ;
    ex:department &lt;http://data.example.com/department/20&gt; .

&lt;http://data.example.com/employee=7400/department=10&gt; 
    ex:employee &lt;http://data.example.com/employee/7400&gt; ;
    ex:department &lt;http://data.example.com/department/10&gt; .
    </pre>

    <p>The following R2RML mapping will produce the desired triples listed above:</p>

    <pre class="ex-mapping">&lt;#TriplesMap3&gt;
    rr:logicalTable [ rr:tableName "EMP2DEPT" ];
    rr:subjectMap [ rr:template "http://data.example.com/employee={EMPNO}/department={DEPTNO}" ];
    rr:predicateObjectMap [
        rr:predicate ex:employee;
        rr:objectMap [ rr:template "http://data.example.com/employee/{EMPNO}" ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:department;
        rr:objectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ];
    ].
    </pre>


    <p>However, if one does <em>not</em> require that the subjects in
    the desired output uniquely identify the rows in the <a
    href="#ex_EMP2DEPT"><code>EMP2DEPT</code> table</a>, the desired output
    may look as follows: </p>

    <pre class="ex-output">
&lt;http://data.example.com/employee/7369&gt; 
    ex:department &lt;http://data.example.com/department/10&gt; ;
    ex:department &lt;http://data.example.com/department/20&gt; .

&lt;http://data.example.com/employee/7400&gt; 
    ex:department &lt;http://data.example.com/department/10&gt;.
    </pre>

    <p>The following R2RML mapping will produce the desired triples:</p>

    <pre class="ex-mapping">&lt;#TriplesMap3&gt;
    rr:logicalTable [ rr:tableName "EMP2DEPT" ];
    rr:subjectMap [
        rr:template "http://data.example.com/employee/{EMPNO}";
    ];
    rr:predicateObjectMap [
      rr:predicate ex:department;
      rr:objectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ];
    ].</pre>


    <h3 id="example-translationtable">2.7 Example: Translating database type codes to IRIs</h3>

    <p>Sometimes, database columns contain codes that need to be translated
    into IRIs, but a direct syntactic translation using string templates is not possible.
    For example, consider a <code>JOB</code> column in the <code>EMP</code>
    table with the following possible values, and IRIs corresponding to
    those database values in the RDF output:</p>

    <table>
    <tr><th>Value</th><th>Corresponding RDF IRI</th></tr>
    <tr><td><code>CLERK</code></td><td><code>http://data.example.com/roles/general-office</code></td></tr>
    <tr><td><code>NIGHTGUARD</code></td><td><code>http://data.example.com/roles/security</code></td></tr>
    <tr><td><code>ENGINEER</code></td><td><code>http://data.example.com/roles/engineering</code></td></tr>
    </table>

    <p>The IRIs are not found in the original database and therefore the mapping
    from database codes to IRIs has to be
    specified in the R2RML mapping. Such translations can be achieved using an
    “<a href="#dfn-r2rml-view">R2RML view</a>”. The view is defined based on a
    SQL query that computes the IRI based on the database value.
    SQL's <code>CASE</code> statement is convenient for this purpose.
    (Alternatively, one could define this view directly in the database.)</p>

    <pre class="ex-mapping">
&lt;#TriplesMap1&gt;
    rr:logicalTable [ rr:sqlQuery """

        SELECT EMP.*, (CASE JOB
            WHEN 'CLERK' THEN 'general-office'
            WHEN 'NIGHTGUARD' THEN 'security'
            WHEN 'ENGINEER' THEN 'engineering'
        END) ROLE FROM EMP

        """ ];
    rr:subjectMap [
        rr:template "http://data.example.com/employee/{EMPNO}";
    ];
    rr:predicateObjectMap [
        rr:predicate ex:role;
        rr:objectMap [ rr:template "http://data.example.com/roles/{ROLE}" ];
    ].
    </pre>

    <p>With the <a href="#example-input-database">example input database</a>,
    this mapping would yield the following triple:</p>

    <pre class="ex-output">
&lt;http://data.example.com/employee/7369&gt; ex:role &lt;http://data.example.com/roles/general-office&gt;.</pre>

    <p>Explicit typing of the resources in a mapping graph with
    <a href="#dfn-r2rml-classes">R2RML classes</a>
    is <em class="rfc2119">OPTIONAL</em> and
    has no effect on the behaviour of an
    <a href="#dfn-r2rml-processor">R2RML processor</a>.
    The <a href="#dfn-mapping-component">mapping component</a>
    represented by any given resource in a mapping graph is defined by the
    presence or absence of certain properties, as defined throughout this
    specification. A resource <em class="rfc2119">SHOULD NOT</em>
    be typed as an R2RML class if it does not meet the definition
    of that class.</p> -->



    <h2 id="logical-sources">Defining Logical Sources</h2>

    <p>A logical source is any source file that is mapped to RDF triples. A logical source is either</p>
    <ul>
      <li>a  Base Source, <code>rml:BaseSource</code></li>
      <li>an RML View, <code>rml:RMLView</code></li>
    </ul>

    <p>A logical source defines which source file is mapped. 
      At least the source Name, <code>rml:sourceName</code>, of the source file should be defined (A/N we should agree on this). 
      <br/>
      A complete logical source definition consist of:
      <ul>
        <li>the source Name, <code>rml:sourceName</code>,</li> 
        <li>the query language, <code>rml:queryLanguage</code>,</li> 
        <li>and the query <code>rml:query</code>.</li>
      </ul>
      The source name, <code>rml:sourceName</code>, locates the source file. <br/>
      The query language,<code>rml:queryLanguage</code>, defines the query language used to refer to the elements of the source file (by default SQL2008 for databases, XPath for XML and JSONPath for JSON files).<br/>
      The query, <code>rml:query</code>, defines the <i>"iterator"</i> in the case of XML and JSON source files. 
      While XML and JSON files need both the query and the query language, <code>rml:queryLanguage</code>, to be defined, CSV and TSV files and databases do not (A/N this should still be decided).
    </p>
    <p>A selector <code>rml:selector</code> is used to refer to
      <ul>
        <li>a column in case of databases,</li>
        <li>a record in case of CSV files,</li> 
        <li>an element in case of XML documents,</li>
        <li>an object in case of a JSON file. </li>
      </ul>
      A selector must be a valid identifier, considering the query language (<code>rnk:queryLanguage</code>) specified. 
    </p>

    <h3>Base Sources and Views (<code>rml:sourceName</code>, <code>rml:query</code>, <code>rml:queryLanguage</code>)</h3>

    <p>A base source is a logical source pointing to a file or a database that contains the data to be mapped. 
      <!-- As an SQL source or view is a logical table containing SQL data from a base table or view in the input database. -->
      A base source or view is represented by a resource that has 
        <ul>
          <li>exactly one source Name<code>rml:sourceName</code> property and</li> 
          <li>zero or one <code>rml:query</code> and <code>rml:queryLanguage</code> properties.</li>
        </ul>
      <ul> (A/N make decision over the followings)
        <li>In the case of databases, the logical source definition requires the <code>rml:sourceName</code> and the <code>rml:queryLanguage</code> to be defined.</li>
        <li>In the case of CSV files, the logical source definition requires only the <code>rml:sourceName</code> to be defined.</li>
        <li>In the case of XML and JSON files, the logical source definition requires all three: the <code>rml:sourceName</code>, <code>rml:query</code> and the <code>rml:queryLanguage</code> to be defined.</li>
      </ul>
    </p>

    <p>
      The value of <code>rr:sourceName</code> specifies the file (A/N or the view name of the base table or view).
      Its value can be either a string (A/N implicit reference to the file) or a valid URI of an existing file.
    </p>

    <!-- <p>A <dfn id="">schema-qualified name</dfn>
    is a sequence of one, two or three valid
    <a href="#dfn-sql-identifier">SQL identifiers</a>, separated
    by the dot character (“<code>.</code>”). The three identifiers
    name, respectively, a catalog, a schema, and a table or view.
    If no catalog or schema is specified, then the
    <a href="#dfn-default-catalog">default catalog</a> and
    <a href="#dfn-default-schema">default schema</a> of the
    <a href="#dfn-sql-connection">SQL connection</a> are assumed.</p>

    <p>The <a href="#dfn-effective-sql-query">effective SQL query</a>
    of a <a href="#dfn-sql-base-table-or-view">SQL base table or view</a> is:</p> 

    <pre>SELECT * FROM <em>{table}</em></pre>
    <p>with <code><em>{table}</em></code>
    replaced with the
    <a href="#dfn-table-or-view-name">table or view name</a>.</p> -->

    <p>The following example shows a logical source specified for a CSV file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Airport.csv"
            ].
        </pre>
    </p>
    <p>The following example shows a logical source specified for an XML file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
          [
            rml:sourceName "http://www.example.com/Transport.xml" ;
            rml:query "transport/bus";
            rml:language ql:XPath;
          ].
      </pre>
    </p>
    <p>The following example shows a logical source specified for a JSON file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
          [
            rml:sourceName "http://www.example.com/files/Venue.json";
            rml:queryLanguage ql:JSONPath;
            rml:query "$.city"
          ].
      </pre>
    </p>


    <h3>RML Views</h3>

    <p>An RML view is a <a href="#logical-source">logical source</a> 
      whose contents are the result of executing a query against the logical source specified. 
      It is represented by a resource that has 
      <ul>
        <li>exactly one <code>rml:queryLanguage</code> property, 
          whose value is the URI (A/N or a string) of the query language specified.
        <li>one <code>rml:query</code> property, 
          whose value is a literal with a lexical form that is a valid query considering the query language specified.
        </li>
      </ul>
    </p>

    <!-- <p class="note">
    R2RML mappings sometimes require data transformation, computation,
    or filtering before
    generating triples from the database. This can be achieved by defining
    a SQL view in the <a href="#dfn-input-database">input database</a>
    and referring to it with
    <a href="#dfn-sql-base-table-or-view"><code>rr:tableName</code></a>.
    However, this approach
    may sometimes not be practical for lack of database privileges or other
    reasons. <a href="#dfn-r2rml-view">R2RML views</a>
    achieve the same effect without requiring changes to the
    input database.</p> -->

    <p class="note">
      An RML view is used when combinations or extracts of logical sources need to be mapped.. (A/N argue more on this)
    </p>

    <p>A query <code>rml:query</code> is a string with a lexical form that is a valid query considering the query language specified.
    (A/N) Argue more regarding possible limitations..</p>

    <p>A query <code>rml:query</code>, can serve one of the following scopes: 
      <ul>(A/N needs better way to express it..)
        <li>a valid query in the specified language (<code>rml:queryLanguage</code>) that tries to retrieve an extract of the data available in the corresponding file and ends up to an RML View</li>
        <li>a valid <i>query-like</i> definition that facilitates the iteration over the specified file and it is used with an <code>rml:logicalSource</code> definition</li>
      </ul>
    </p>

    <h2 id="triples-map">Mapping Logical Sources to RDF with Triples Maps</h2>

    <p>A triples map specifies a rule for translating 
      <ul>
        <li>each row of a database, </li> 
        <li>each record of a CSV file, </li>
        <li>each element of an XML file, </li>
        <li>each object of a JSON file, </li>
      </ul>
      to zero or more RDF triples.</li>
    </p>

    <!-- <p>The RDF triples generated from one row in the logical table all share the same subject.</p> -->

    <p>A triples map in RML is defined as a triples map in RML.<br/>
       A triples map is represented by a resource that references the following other resources:</p>

    <ul>
      <li>It must have exactly one <code>rr:logicalSource</code> property.
          Its value is a <a href="#logical-source">logical source</a>
          that specifies the file or the database to be mapped to triples.</li>

    <li>It must have exactly one <a href="#subject-map">subject map</a>
        that specifies how to generate a subject for each row/record/element/object of the
        logical source (database/CSV file/XML file/JSON file accordingly). It may be specified in two ways:
      <ol>
        <li>using the <code>rr:subjectMap</code> property, whose value must be the subject map, or</li>
        <li>using the constant shortcut property, <code>rr:subject</code>.</li>
      </ol>
    </li>

    <li>It may have zero or more <code>rr:predicateObjectMap</code> properties,
        whose values must be a <a href="#predicate-object-map">predicate-object maps</a>.
        <code>rr:predicateObjectMap</code> properties specify pairs of predicate maps and object maps that,
        together with the subjects generated by the subject map, may form one or more
        <a href="#rdf-triple">RDF triples</a> for each row/record/element/object of the (database/CSV file/XML file/JSON file respectively).</li>
    </ul>
    
    <p>The references of all <a href="#term-map">term maps</a> of a triples map (subject map, predicate maps, object maps, graph maps) must be references to rows/records/elements/objects that exist in the term map's <a href="#logical-table">logical source</a>.</p>

    <p>The following example shows a <a href="#triples-map">triples map</a> including 
        its logical source, the subject map, and two predicate-object maps for an XML file.
    </p>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

        &lt;#TransportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Transport.xml" ;
              rml:query "transport/bus";
              rml:language ql:XPath;
            ];
          rr:subjectMap 
          [ 
            rr:template "http://trans.example.com/{/transport/bus@id}";
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop@id";
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop"
            ]
          ].
      </pre>

    <h3 id="predicate-object-map">Creating Properties and Values with Predicate-Object Maps</h3>

    <p>A <span id="predicate-object-map">predicate-object map</span> is a function that creates one or more predicate-object pairs for
       each row/record/element/object of a <a href="#logical-source">logical source</a>. 
       It is used in conjunction with a <a href="#subject-map">subject map</a> to generate <a href="#rdf-triple">RDF triples</a> in a
       <a href="#triples-map">triples map</a>.
     </p>

    <p>A <a href="#predicate-object-map">predicate-object map</a> is represented by a resource that references the following other resources:</p>

    <ul>
      <li>
        <p>One or more <a href="#predicate-map">predicate maps</a>.
        Each of them may be specified in one of two ways:</p>
        <ol>
          <li>using the <code>rr:predicateMap</code> property, whose value must be a <a href="#predicate-map">predicate map</a>, or</li>
          <li>using the <a href="#constant-shortcut-property">constant shortcut property</a> <code>rr:predicate</code>.</li>
        </ol>
      </li>
    <li>
      <p>One or more <a href="#object-map">object maps</a> or <a href="#referencing-object-map">referencing object maps</a>.
      Each of them may be specified in one of two ways:</p>
      <ol>
        <li>using the <code>rr:objectMap</code> property, whose value must be either an
          <a href="#object-map">object map</a>, or a
          <a href="#referencing-object-map">referencing object map</a>.
        </li>
        <li>using the <a href="#constant-shortcut-property">constant shortcut property</a> <code>rr:object</code>.</li>
      </ol>
    </li>
    </ul>

    <p>Both <dfn id="predicate-map">predicate maps</dfn> and <dfn id="object-map">object maps</dfn> are <a href="#term-map">term maps</a>.</p>

    <h2 id="term-map">Creating RDF Terms with Term Maps</h2>

    <p>(A/N) unchanged compared to R2RML</p>

    <p>An <span id="rdf-term">RDF term</span> is either an <a href="#iri">IRI</a>, or a <a href="#blank-node">blank node</a>,
       or a <a href="#literal">literal</a>.
    </p>

    <p>
      A <span id="term-map">term map</span> is a function that generates an <a href="#rdf-term">RDF term</a> from a
      <a href="#logical-reference">logical reference</a>. The result of that function is known as the term map's
      <a href="#generated-rdf-term">generated RDF term</a>.
    </p>

    <p>Term maps are used to generate the subjects, predicates and objects of the <a href="#rdf-triple">RDF triples</a> 
      that are generated by a <a href="#triples-map">triples map</a>. 
      Consequently, there are several kinds of <a href="#dfn-term-map">term maps</a>, depending on where in the mapping they occur:
      <a href="#subject-map">subject maps</a>,
      <a href="#predicate-map">predicate maps</a>,
      <a href="#object-map">object maps</a> and
      <a href="#graph-map">graph maps</a>.
    </p>

    <p>A <a href="#term-map">term map</a> <dfn id="must">must</dfn> be exactly one of the following:</p>

    <ul>
      <li>a <a href="#constant-valued-term-map">constant-valued term map</a>,</li>
      <li>a <a href="#selector-valued-term-map">selector-valued term map</a>,</li>
      <li>a <a href="#template-valued-term-map">template-valued term map</a>.</li>
    </ul>

    <p>The <dfn id="reference">references</dfn> of a <a href="#term-map">term map</a> are 
        the set of <a href="#column-name">column names</a> referenced in the term map and depend on the type of term map.
    </p>

    <h3 id="constant">Constant RDF Terms (<code>rr:constant</code>)</h3>

    <p>(A/N) unchanged compared to R2RML</p>

    <p>A <dfn id="constant-valued-term-map">constant-valued term map</dfn> is a <a href="#dfn-term-map">term map</a> that ignores the <a href="#logical-reference">logical references</a> specified by the query (A/N as an iterator) and always generates the same RDF term. 
    <br/>  
    A constant-valued term map is represented by a
    resource that has exactly one <code>rr:constant</code> property.
    </p>

    <p>The <dfn id="constant-value">constant value</dfn> of a <a href="#constant-valued-term-map">constant-valued term map</a>
    is the RDF term that is the value of its <code>rr:constant</code> property.</p>

    <p>If the <a href="#constant-valued-term-map">constant-valued term map</a> is a <a href="#subject-map">subject map</a>,
    <a href="#predicate-map">predicate map</a> or <a href="#graph-map">graph map</a>, then its <a href="#constant-value">constant value</a>
    must be an <a href="#iri">IRI</a>.</p>

    <p>
      If the <a href="#constant-valued-term-map">constant-valued term map</a> is an <a href="#object-map">object map</a>, then its
      <a href="#constant-value">constant value</a> must be an <a href="#iri">IRI</a> or <a href="#literal">literal</a>.
    </p>

    <p>The <a href="#reference">references</a> of a <a href="#constant-valued-term-map">constant-valued term map</a> is the empty set.</p>

    <p>Constant-valued term maps can be expressed more concisely using the <dfn id="constant-shortcut-property">constant shortcut properties</dfn>
    <code>rr:subject</code>, <code>rr:predicate</code>, <code>rr:object</code> and <code>rr:graph</code>.
    Occurrences of these properties must be treated exactly as if the following triples were present in the mapping graph instead:</p>

    <table rules="all" summary="Constant shortcut properties and their replacements">
      <tr>
        <th>Triple involving constant shortcut property</th>
        <th>Replacement triples</th>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:subject <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:subjectMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:predicate <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:predicateMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:object <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:objectMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:graph <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:graphMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
    </table>

    <p>
      The following example shows a <a href="#predicate-object-map">predicate-object map</a> 
      that uses a constant-valued term map both for its predicate and for its object.
    </p>
    <pre class="ex-mapping">
      [] rr:predicateMap [ rr:constant rdf:type ];
         rr:objectMap [ rr:constant ex:Employee ].
    </pre>
    
    <p>If added to a <a href="#triples-map">triples map</a>,
    this predicate-object map would add the following triple to
    all resources <code>?x</code> generated by the triples map:</p>
    <pre class="ex-output">
      ?x rdf:type ex:Employee.
    </pre>

    <p>The following example uses
    <a href="#constant-shortcut-property">constant shortcut properties</a>
    and is equivalent to the example above:</p>

    <pre class="ex-mapping">
      [] rr:predicate rdf:type;
         rr:object ex:Employee.
    </pre>

    <h3 id="from-column">From a Selector (<code>rml:selector</code>)</h3>

    <p>A <dfn id="selector-valued-term-map">selector-valued term map</dfn>
    is a <a href="#term-map">term map</a> that is represented by
    a resource that has exactly one <code>rml:selector</code> property.</p>

    <p>The value of the <code>rml:selector</code> property must be a valid <a href="#selector">selector</a>. 
       The <dfn id="selector-value">selector value</dfn> of the term map is the data value of that column in a given 
       <a href="#logical-reference">logical reference</a>.
    </p>

    <p>The <a href="#iterator">iterator</a> of a <a href="#selector-valued-term-map">selector-valued term map</a>
    is the singleton set containing the value of the term map's <code>rml:selector</code> property.</p>

    <p>The following examples defines an <a href="#object-map">object map</a>that generates <a href="#literal">literals</a> for each different case of file formats.

    <h4>Selector for a database</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "DNAME" ].
    </pre>

    <h4>Selector for a CSV file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "name" ].
    </pre>

    <h4>Selector for an XML file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "/city/name" ].
    </pre>

    <h4>Selector for a JSON file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "$.city.name" ].
    </pre>

    <p>Using the sample specified in the beginning.</p>

    <h3 id="from-template">From a Template (<code>rr:template</code>)</h3>

    <p>A <dfn id="template-valued-term-map">template-valued term map</dfn> is a <a href="#term-map">term map</a> 
      that is represented by a resource that has exactly one <code>rr:template</code> property.
      The value of the <code>rr:template</code> property must be a valid <a href="#string-template">string template</a>.
    </p>

    <p>A <dfn id="string-template">string template</dfn> is a format string that can be used to build strings from multiple
    components. It can reference <a href="#column-name">column names</a> by enclosing them in curly braces (“<code>{</code>” and “<code>}</code>”).
    The following syntax rules apply to valid string templates:</p>

    <ul>
    <li>Pairs of unescaped curly braces must enclose valid <a href="#selector-name">selector names</a> according to the specified query language.</li>
    <li>Curly braces that do not enclose selector's names must be escaped by a backslash character (“<code>\</code>”). 
        This also applies to curly braces within column names.</li>
    <li>Backslash characters (“<code>\</code>”) must be escaped by preceding them with another backslash character, yielding “<code>\\</code>”.
    This also applies to backslashes within column names.</li>
    <li>There <em class="rfc2119">SHOULD</em> be at least one pair
    of unescaped curly braces.</li>
    <li>If a template contains multiple pairs of unescaped curly braces,
    then any pair should be separated from the next one
    by a <dfn id="safe-separator">safe separator</dfn>. This is any character or
    string that does not occur anywhere
    in any of the data values of either referenced column; or in the
    <a href="#iri-safe">IRI-safe versions</a> of the data values,
    if the <a href="#term-type">term type</a> is <code>rr:IRI</code>
    (see <a href="#note-safe-separators">note below</a>).</li>
    </ul>

    <p>The <dfn id="template-value">template value</dfn> of the term map for a given <a href="#dfn-logical-table-row">logical iterator</a>
    is determined as follows:</p>

    <ol>
      <li>Let <code><em>result</em></code> be the <a href="#string-template">template string</a></li>
      <li>For each pair of unescaped curly braces in <code><em>result</em></code>:
        <ol>
          <li>Let <code><em>value</em></code> be the data value of the selector whose name is enclosed in the curly braces</li>
          <li>If <code><em>value</em></code> is <code>NULL</code>, then return <code>NULL</code></li>
          <li>Let <code><em>value</em></code> be the <a href="#natural-rdf-lexical-form">natural RDF lexical form</a>
          corresponding to <code><em>value</em></code></li>
          <li>If the <a href="#term-type">term type</a> is <code>rr:IRI</code>, 
              then replace the pair of curly braces with an <a href="#iri-safe">IRI-safe version</a> of
              <code><em>value</em></code>; otherwise, replace the pair of curly braces with <code><em>value</em></code>
          </li>
        </ol>
      </li>
      <li>Return <code><em>result</em></code></li>
    </ol>
    <p>
      (A/N make sure this is fullfield)
      The <dfn id="iri-safe">IRI-safe version</dfn> of a string is obtained by applying the following transformation to any character
      that is not in the <cite><a class="norm" href="http://tools.ietf.org/html/rfc3987#section-2.2">
      <code>iunreserved</code> production</a></cite> in [<cite><a href="#RFC3987">RFC3987</a></cite>]:
    </p>

    <ol>
    <li>Convert the character to a sequence of one or more octets using <cite><a class="norm" href="http://tools.ietf.org/html/rfc3629">UTF-8</a></cite>
    [<cite><a href="#RFC3629">RFC3629</a></cite>]</li>
    <li><cite><a class="norm" href="http://tools.ietf.org/html/rfc3986#section-2.1">Percent-encode</a></cite>
    each octet [<cite><a href="#RFC3986">RFC3986</a></cite>]</li>
    </ol>

    <!-- <p>The following table shows examples of strings and their IRI-safe versions:</p>

    <table rules="all" id="example-iri-safe">
      <tr><th>String</th><th>IRI-safe version</th></tr>
      <tr><td>42</td><td>42</td></tr>
      <tr><td>Hello World!</td><td>Hello%20World%21</td></tr>
      <tr><td>2011-08-23T22:17:00Z</td><td>2011-08-23T22%3A17%3A00Z</td></tr>
      <tr><td>~A_17.1-2</td><td>~A_17.1-2</td></tr>
      <tr><td>葉篤正</td><td>葉篤正</td></tr>
    </table> 

    <p class="note">R2RML always performs percent-encoding when IRIs are
    generated from string templates. If IRIs need to be generated without
    percent-encoding, then <code>rr:column</code> should be used instead
    of <code>rr:template</code>, with an
    <a href="#dfn-r2rml-view">R2RML view</a> that performs the string
    concatenation.</p> -->

    <p class="note" id="note-safe-separators">
      (A/N look thoroughly into this)
      In the case of string templates
      that generate IRIs, any single character that is legal in an IRI, but percent-encoded in the <a href="#iri-safe">IRI-safe version</a> 
      of a data value, is a <a href="#safe-separator">safe separator</a>.
      This includes in particular the eleven <code>sub-delim</code> characters defined in
      [<cite><a href="#RFC3987">RFC3987</a></cite>]: <code>!$&amp;'()*+,;=</code>
    </p>

    <p>The <a href="#referenced-columns">referenced selectors</a> of a <a href="#template-valued-term-map">template-valued term map</a>
    is the set of <a href="#column-name">selectors</a> enclosed in unescaped curly braces in the <a href="#dfn-string-template">template string</a>.
    </p>

    <!-- <p>The following example defines a
    <a href="#subject-map">subject map</a> that generates
    <a href="#dfn-iri">IRIs</a> from the
    <code>DEPTNO</code> column of a logical table.</p>
    <pre class="ex-mapping">
[] rr:subjectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ].</pre>

    <p>Using the sample row from the
    <a href="#ex_DEPT"><code>DEPT</code> table</a> as a logical table
    row, the <a href="#dfn-template-value">template value</a> of the subject map
    would be:</p>

    <pre class="ex-output">http://data.example.com/department/10</pre>

    <p>The following example shows how an <a href="#dfn-iri-safe">IRI-safe</a>
    template value is created:</p> -->
    <pre class="ex-mapping">
      [] rr:subjectMap [ rr:template "http://data.example.com/site/{LOC}" ].</pre>

    <!-- <p>Using the sample row from the
    <a href="#ex_DEPT"><code>DEPT</code> table</a> as a logical table
    row, the <a href="#dfn-template-value">template value</a> of the subject map
    would be:</p> -->

    <pre class="ex-output">http://data.example.com/site/NEW%20YORK</pre>

    <p>
      The space character is not in the <code>iunreserved</code> set,
      and therefore percent-encoding is applied to the character, yielding
      “<code>%20</code>”.
    </p>

    <p>The following example shows the use of backslash escapes in string templates. 
      The template will generate a fancy title such as</p>
      <pre>{{{ \o/ Hello World! \o/ }}}</pre>
      <p>from a string “<code>Hello World!</code>” in the <code>TITLE</code>
        column. By default, <code>rr:template</code> generates IRIs. Since
        the intention here is to create a literal instead,
        the <a href="#dfn-term-type">term type</a> has to be set.
      </p>
      <pre class="ex-mapping">
        [] rr:objectMap [
            rr:template "\\{\\{\\{ \\\\o/ {TITLE} \\\\o/ \\}\\}\\}";
            rr:termType rr:Literal;
        ].
      </pre>
      <p>Note that because <a class="norm" href="http://www.w3.org/TR/turtle/#string">
        backslashes need to be escaped by a second backslash in the Turtle syntax</a>
        [<cite><a href="#TURTLE">TURTLE</a></cite>],
        a double backslash is needed to escape each curly brace, and to get one literal backslash in the output one needs to write
        four backslashes in the template.
      </p>


    <h3 id="termtype">IRIs, Literal, Blank Nodes (<code>rr:termType</code>)</h3>
    <p>(A/N) unchanged compared to R2RML</p>
    <p>
      The <dfn id="term-type">term type</dfn> of a
      <a href="#selector-valued-term-map">selector-valued term map</a> or
      <a href="#template-valued-term-map">template-valued term map</a>
      determines the kind of <a href="#dfn-generated-rdf-term">generated RDF term</a>
      (<a href="#iri">IRIs</a>, <a href="#dfn-blank-node">blank nodes</a> or <a href="#dfn-literal">literals</a>).
    </p>

    <p>
      If the term map has an optional <code>rr:termType</code> property,
      then its <a href="#term-type">term type</a> is the value of that property.
       The value must be an IRI and must be one of the following options:</p>
      <ul>
        <li>If the term map is a <a href="#subject-map">subject map</a>:
          <code>rr:IRI</code> or <code>rr:BlankNode</code>
        </li>
        <li>If the term map is a <a href="#predicate-map">predicate map</a>:
          <code>rr:IRI</code>
        </li>
        <li>If the term map is an <a href="#object-map">object map</a>:
          <code>rr:IRI</code>, 
          <code>rr:BlankNode</code>, or 
          <code>rr:Literal</code>
        </li>
        <li>If the term map is a <a href="#graph-map">graph map</a>: 
          <code>rr:IRI</code>
        </li>
      </ul>

    <p>If the term map does not have a <code>rr:termType</code> property, then its <a href="#dfn-term-type">term type</a> is: </p>

    <ul>
      <li><code>rr:Literal</code>, if it is an <a href="#dfn-object-map">object map</a> and at least one of the following conditions is true:
        <ul>
          <li>It is a <a href="#column-valued-term-map">column-based term map</a>.</li>
          <li>It has a <code>rml:queryLanguage</code> property (and thus a
            <a href="#dfn-specified-language-tag">specified language tag</a>).
          </li>
          <li>It has a <code>rr:datatype</code> property (and thus a <a href="#specified-datatype">specified datatype</a>).</li>
        </ul>
      </li>
      <li><code>rr:IRI</code>, otherwise.</li>
    </ul>

    <p class="note">Term maps with term type <code>rr:IRI</code> cause <a href="#data-error">data errors</a> 
      if the value is not a valid <a href="#dfn-iri">IRI</a> (see <a href="#dfn-generated-rdf-term">generated RDF term</a> for details).
      Data values from the input database may require percent-encoding before they can be used in IRIs.
      <a href="#template-valued-term-map">Template-valued term maps</a> are a convenient way of percent-encoding data values.
    </p>

    <p class="note">
      <a href="#constant-valued-term-map">Constant-valued term maps</a>
      are not considered as having a <a href="#dfn-term-type">term type</a>,
      and specifying <code>rr:termType</code> on these term maps has no effect.
      The type of the generated RDF term is determined directly by the value of <code>rr:constant</code>: 
      If it is an IRI, then an IRI will be generated; if it is a literal, a literal will be
      generated.
    </p>


    <h3 id="language-tags">7.5 Language Tags (<code>rr:language</code>)</h3>

    <p>A <a href="#dfn-term-map">term map</a> with a
    <a href="#dfn-term-type">term type</a> of <code>rr:Literal</code>
    <em class="rfc2119">MAY</em> have a
    <dfn id="dfn-specified-language-tag">specified language tag</dfn>.
    It is represented by the <code>rr:language</code> property on a term map.
    If present, its value <em class="rfc2119">MUST</em> be
    a valid <a href="#dfn-language-tag">language tag</a>.</p>

    <p>A specified language tag causes generated literals to be
    language-tagged plain literals. In the following example, plain
    literals with language tag “<code>en-us</code>” (U.S. English)
    will be generated for the data values in the <code>DNAME</code>
    column.</p>

    <pre class="ex-mapping">
[] rr:objectMap [ rr:column "DNAME"; rr:language "en-us" ].
</pre>


    <h3 id="typed-literals">7.6 Typed Literals (<code>rr:datatype</code>)</h3>

    <p>A <dfn id="dfn-datatypeable-term-map">datatypeable term map</dfn> is a
    <a href="#dfn-term-map">term map</a> with a
    <a href="#dfn-term-type">term type</a> of <code>rr:Literal</code>
    that does not have a
    <a href="#dfn-specified-language-tag">specified language tag</a>.</p>

    <p>Datatypeable term maps may generate
    <a href="#dfn-typed-literal">typed literals</a>. The datatype
    of these literals can be automatically determined based on the
    SQL datatype of the underlying logical table column (producing a
    <a href="#dfn-natural-rdf-literal">natural RDF literal</a>), or
    it can be explicitly overridden using <code>rr:datatype</code>
    (producing a <a href="#dfn-datatype-override-rdf-literal">datatype-override
    RDF literal</a>).</p>

    <p>A <a href="#dfn-datatypeable-term-map">datatypeable term map</a>
    <em class="rfc2119">MAY</em> have a <code>rr:datatype</code> property.
    Its value <em class="rfc2119">MUST</em> be an <a href="#dfn-iri">IRI</a>.
    This IRI is the <dfn id="dfn-specified-datatype">specified datatype</dfn>
    of the term map.</p>

    <p>A term map <em class="rfc2119">MUST NOT</em> have more than one
    <code>rr:datatype</code> value.</p>

    <p>A term map that is not a
    <a href="#dfn-datatypeable-term-map">datatypeable term map</a>
    <em class="rfc2119">MUST NOT</em> have an <code>rr:datatype</code>
    property.</p>

    <p>The <dfn id="dfn-implicit-sql-datatype">implicit SQL datatype</dfn>
    of a <a href="#dfn-datatypeable-term-map">datatypeable term map</a> is
    <code>CHARACTER VARYING</code> if the term map is a
    <a href="#dfn-template-valued-term-map">template-valued term map</a>;
    otherwise, it is the SQL datatype of the respective column in the
    <a href="#dfn-logical-table-row">logical table row</a>.</p>

    <p>See <a href="#dfn-generated-rdf-term">generated RDF term</a>
    for further details on generating literals from term maps.</p>

    <p class="note">One cannot explicitly state that a
    <a href="#dfn-plain-literal">plain literal</a> without
    <a href="#dfn-language-tag">language tag</a> should be generated.
    They are the default for string columns. To generate one from a
    non-string column, a
    <a href="#dfn-template-valued-term-map">template-valued term map</a>
    with a template such as <code>"{MY_COLUMN}"</code> and a
    <a href="#dfn-term-type">term type</a> of <code>rr:Literal</code>
    can be used.</p>

    <p>The following example shows an <a href="#dfn-object-map">object map</a>
    that overrides the default datatype of the logical table with
    an explicitly specified <code>xsd:positiveInteger</code> type.
    A <a href="#dfn-datatype-override-rdf-literal">datatype-override
    RDF literal</a> of that datatype will be generated from whatever
    is in the <code>EMPNO</code> column.</p>

    <pre class="ex-mapping">
[] rr:objectMap [ rr:column "EMPNO"; rr:datatype xsd:positiveInteger ].
</pre>


    <h3 id="inverse">7.7 Inverse Expressions (<code>rr:inverseExpression</code>)</h3>

    <p>An <dfn id="dfn-inverse-expression">inverse expression</dfn> is a
    <a href="#dfn-string-template">string template</a> associated with
    a <a href="#dfn-column-valued-term-map">column-valued term map</a> or
    <a href="#dfn-template-valued-term-map">template-value term map</a>.
    It is represented by the value of the <code>rr:inverseExpression</code>
    property. This property is <em class="rfc2119">OPTIONAL</em> and there
    <em class="rfc2119">MUST NOT</em> be more than one for a term map.</p>

    <p>Inverse expressions are useful for optimizing
    <a href="#dfn-term-map">term maps</a>
    that reference derived columns in
    <a href="#dfn-r2rml-view">R2RML views</a>.
    An inverse expression specifies an expression that
    allows “reversing” of a <a href="#dfn-generated-rdf-term">generated RDF term</a>
    and the construction of a SQL query that efficiently retrieves the
    <a href="#dfn-logical-table-row">logical table row</a> from which the
    term was generated. In particular, it allows the use of indexes
    on the underlying relational tables.</p>

    <p>Every pair of unescaped curly braces in the inverse expression is a
    <dfn id="dfn-column-reference">column reference in an inverse expression</dfn>.
    The string between the braces <em class="rfc2119">MUST</em> be a valid
    <a href="#dfn-column-name">column name</a>.</p>

    <p>An <a href="#dfn-inverse-expression">inverse expression</a>
    <em class="rfc2119">MUST</em> satisfy the following condition:</p>

    <ul>
    <li>Let <em>t</em> be the <a href="#dfn-logical-table">logical table</a>
    associated with this <a href="#dfn-term-map">term map</a></li>
    <li>Every <a href="#dfn-column-reference">column reference</a> in the
    inverse expression <em class="rfc2119">MUST</em> be an existing column
    in <em>t</em></li>
    <li>Given a <a href="#dfn-logical-table-row">logical table row</a>
    <em>r</em> in <em>t</em>, let <em>instantiation(r)</em> be the result of
    replacing each <a href="#dfn-column-reference">column reference</a>
    <em>c</em> in the inverse expression with:
      <ul>
      <li>the <a href="#dfn-quoted-data-value">quoted and escaped data value</a>
      of column
      <em>c</em> in <em>r</em>, if <em>c</em> is a
      <a href="#dfn-referenced-columns">referenced column</a>
      in the <a href="#dfn-term-map">term map</a></li>
      <li>the <a href="#dfn-column-name">column name</a>
      of column <em>c</em>, otherwise</li>
      </ul>
    </li>

    <li>Given a <a href="#dfn-logical-table-row">logical table row</a>
    <em>r</em> in <em>t</em>, let <em>same-term(r)</em>
    be the set of logical table rows in <em>t</em> that are the
    result of executing the following SQL query over the
    <a href="#dfn-sql-connection">SQL connection</a>:

    <pre>SELECT * FROM (<em>{query}</em>) AS tmp WHERE <em>{expr}</em></pre>

    where <code><em>{query}</em></code> is the
    <a href="#dfn-effective-sql-query">effective SQL query</a>
    of <em>t</em>, and <code><em>{expr}</em></code> is
    <em>instantiation(r)</em></li>

    <li>For every <a href="#dfn-logical-table-row">logical table row</a>
    <em>r</em> in <em>t</em> whose
    <a href="#dfn-generated-rdf-term">generated RDF term</a> <em>g</em>
    is not <code>NULL</code>, <em>same-term(r)</em>
    <em class="rfc2119">MUST</em> be exactly the set of logical table rows
    in <em>t</em> whose
    <a href="#dfn-generated-rdf-term">generated RDF term</a> is
    also <em>g</em>.</li>
    </ul>

    <p>For example, for the <code>DEPTID</code> column in the
    <a href="#dfn-logical-table">logical table</a> used for
    mapping the <code>DEPT</code> table in
    <a href="#ex-r2rml-view">this example mapping</a>,
    an inverse expression could be defined as follows:</p>

    <pre class="ex-mapping">
[] rr:column "DEPTID";
   rr:inverseExpression "{DEPTNO} = SUBSTRING({DEPTID}, CHARACTER_LENGTH('Department')+1)";
</pre>

    <p>This facilitates the use of an existing index on the <code>DEPTNO</code>
    column of the <a href="#ex_DEPT">DEPT table</a>.</p>

    <p>A <dfn id="dfn-quoted-data-value">quoted and escaped data value</dfn>
    is any SQL string that matches the <code>&lt;literal&gt;</code> or
    <code>&lt;null specification&gt;</code> productions of 
    [<cite><a href="#SQL2">SQL2</a></cite>]. This string can be used in
    a SQL query to specify a SQL data value. Examples:</p>

    <ul>
    <li><code>27</code></li>
    <li><code>'foo'</code></li>
    <li><code>'foo''bar'</code></li>
    <li><code>TRUE</code></li>
    <li><code>DATE '2011-11-11'</code></li>
    <li><code>NULL</code></li>
    </ul>


    <h2 id="foreign-key">8 Foreign Key Relationships among Logical Tables (<code>rr:parentTriplesMap</code>, <code>rr:joinCondition</code>, <code>rr:child</code> and <code>rr:parent</code>)</h2>

    <div class="figure">
     <img src="images/ref-object-map.png" alt="Diagram: The properties of referencing object maps"/>
      <br /><br />
      Figure 5: The properties of referencing object maps
    </div>

    <p>A <dfn id="dfn-referencing-object-map">referencing object map</dfn>
    allows using the subjects of another
    <a href="#dfn-triples-map">triples map</a> as the objects generated
    by a <a href="#dfn-predicate-object-map">predicate-object map</a>.
    Since both triples maps may be based on different
    <a href="#dfn-logical-table">logical tables</a>, this may require
    a join between the logical tables. This is not restricted to
    1:1 joins.</p>

    <p>A referencing object map is represented by a resource that:</p>

    <ul>
    <li>has exactly one <code>rr:parentTriplesMap</code> property, whose value
    <em class="rfc2119">MUST</em> be a
    <a href="#dfn-triples-map">triples map</a>, known as the
    referencing object map's <dfn id="dfn-parent-triples-map">parent
    triples map</dfn>.</li>

    <li><em class="rfc2119">MAY</em> have one or more
    <code>rr:joinCondition</code> properties, whose values
    <em class="rfc2119">MUST</em> be
    <a href="#dfn-join-condition">join conditions</a>.</li>
    </ul>

    <p>A <dfn id="dfn-join-condition">join condition</dfn> is represented
    by a resource that has exactly one value for each of the following
    two properties:</p>

    <ul>
    <li><code>rr:child</code>, whose value is known as the join condition's
    <dfn id="dfn-child-column">child column</dfn> and
    <em class="rfc2119">MUST</em> be a
    <a href="#dfn-column-name">column name</a> that exists in the
    <a href="#dfn-logical-table">logical table</a> of the
    <a href="#dfn-triples-map">triples map</a> that contains the
    referencing object map</li>
    <li><code>rr:parent</code>, whose value is known as the join condition's
    <dfn id="dfn-parent-column">parent column</dfn> and
    <em class="rfc2119">MUST</em> be a
    <a href="#dfn-column-name">column name</a> that exists in the
    <a href="#dfn-logical-table">logical table</a> of the
    referencing object map's
    <a href="#dfn-parent-triples-map">parent triples map</a>.</li>
    </ul>

    <p>The <dfn id="dfn-child-query">child query</dfn> of a
    <a href="#dfn-referencing-object-map">referencing object map</a>
    is the <a href="#dfn-effective-sql-query">effective SQL query</a>
    of the <a href="#dfn-logical-table">logical table</a> of the
    <a href="#dfn-term-map">term map</a> containing
    the referencing object map.</p>

    <p>The <dfn id="dfn-parent-query">parent query</dfn> of a
    <a href="#dfn-referencing-object-map">referencing object map</a>
    is the <a href="#dfn-effective-sql-query">effective SQL query</a>
    of the <a href="#dfn-logical-table">logical table</a> of its
    <a href="#dfn-parent-triples-map">parent triples map</a>.</p>

    <p>If the <a href="#dfn-child-query">child query</a> and
    <a href="#dfn-parent-query">parent query</a> of a
    <a href="#dfn-referencing-object-map">referencing object map</a>
    are not identical, then the referencing object map
    <em class="rfc2119">MUST</em> have at least one
    <a href="#dfn-join-condition">join condition</a>.</p>

    <p>The <dfn id="dfn-joint-sql-query">joint SQL query</dfn> of a 
    <a href="#dfn-referencing-object-map">referencing object map</a>
    is:</p>

    <ul>
    <li>If the referencing object map has no
    <a href="#dfn-join-condition">join condition</a>:
    <pre>SELECT * FROM (<em>{child-query}</em>) AS tmp</pre></li>
    <li>If the referencing object map has at least one join condition:
    <pre>
SELECT * FROM (<em>{child-query}</em>) AS child,
              (<em>{parent-query}</em>) AS parent
        WHERE child.<em>{child-column1}</em>=parent.<em>{parent-column1}</em>
          AND child.<em>{child-column2}</em>=parent.<em>{parent-column2}</em>
          AND ...</pre>
    where <code><em>{child-query}</em></code> is the referencing object map's
    <a href="#dfn-child-query">child query</a>,
    <code><em>{parent-query}</em></code> is its
    <a href="#dfn-parent-query">parent query</a>,
    <code><em>{child-column1}</em></code> and
    <code><em>{parent-column1}</em></code> are the
    <a href="#dfn-child-column">child column</a> and 
    <a href="#dfn-parent-column">parent column</a> of its first
    <a href="#dfn-join-condition">join condition</a>, and so on.
    The order of the join conditions is chosen arbitrarily.</li>
    </ul>

    <p>The <a href="#dfn-joint-sql-query">joint SQL query</a> is used when
    <a href="#dfn-generating-rdf-triples">generating RDF triples</a> from
    <a href="#dfn-referencing-object-map">referencing object maps</a>.</p>

    <p>The following example shows a referencing object map as
    part of a <a href="#dfn-predicate-object-map">predicate-object map</a>:</p>
    <pre class="ex-mapping" id="ex-ref-object-map1">
[] rr:predicateObjectMap [
    rr:predicate ex:department;
    rr:objectMap [
        rr:parentTriplesMap &lt;#TriplesMap2&gt;;
        rr:joinCondition [
            rr:child "DEPTNO";
            rr:parent "DEPTNO";
        ];
    ];
].</pre>
    <p>If the logical table of the surrounding
    triples map is <code>EMP</code>, and the logical table
    of <code>&lt;#TriplesMap2&gt;</code> is <code>DEPT</code>,
    this would result in a join between these two tables
    with the condition</p>
    <pre>EMP.DEPTNO = DEPT.DEPTNO</pre>
    <p>and the objects of the triples would be generated using
    the subject map of <code>&lt;#TriplesMap2&gt;</code>.</p>

    <p>Given the two <a href="#example-input-database">example
    tables</a>, and subject maps as defined in the
    <a href="#example-simple">example mapping</a>, this would
    result in a triple:</p>

    <pre class="ex-output">&lt;http://data.example.com/employee/7369&gt; ex:department &lt;http://data.example.com/department/10&gt;.</pre>

    <p>The following example shows a
    <a href="#dfn-referencing-object-map">referencing object map</a>
    that does not have a <a href="#dfn-join-condition">join condition</a>.
    It creates two kinds of resources from the
    <a href="#example-input-database"><code>DEPT</code> table</a>:
    departments and sites.</p>

    <pre class="ex-mapping" id="ex-ref-object-map2">&lt;#DeptTriplesMap&gt;
    rr:logicalTable [ rr:tableName "DEPT" ];
    rr:subjectMap [
        rr:template "department/{DEPTNO}";
        rr:class ex:Department;
    ];
    rr:predicateObjectMap [
        rr:predicate ex:location;
        rr:objectMap [ rr:parentTriplesMap &lt;#SiteTriplesMap&gt; ];
    ].

&lt;#SiteTriplesMap&gt;
    rr:logicalTable [ rr:tableName "DEPT" ];
    rr:subjectMap [
        rr:template "site/{LOC}";
        rr:class ex:Site;
    ];
    rr:predicateObjectMap [
        rr:predicate ex:siteName;
        rr:objectMap [ ex:column "LOC" ];
    ].</pre>

    <p>An <code>ex:Site</code> resource is created
    for each distinct value in the <code>LOC</code> column, using the
    <code>&lt;#SiteTriplesMap&gt;</code>. Departments and sites are
    linked by <code>ex:location</code> triples, and the objects
    of these triples are specified using a
    <a href="#dfn-referencing-object-map">referencing object map</a>
    that references the sites triples map. No join condition is
    needed as both triples maps use the same logical table
    (the base table <code>DEPT</code>). Given the example table,
    this mapping would result in four triples
    (assuming an appropriate <a href="#dfn-base-iri">base IRI</a>):</p>

    <pre class="ex-output">&lt;http://data.example.com/department/10&gt; rdf:type ex:Department.
&lt;http://data.example.com/department/10&gt; ex:location &lt;http://data.example.com/site/NEW%20YORK&gt;.
&lt;http://data.example.com/site/NEW%20YORK&gt; rdf:type ex:Site.
&lt;http://data.example.com/site/NEW%20YORK&gt; ex:siteName "NEW YORK".</pre>


    <h2 id="named-graphs">Assigning Triples to Named Graphs</h2>

    <div class="figure">
     <img src="images/graph-map.png" alt="Diagram: The properties of graph maps"/>
      <br /><br />
      Figure 6: The properties of graph maps
    </div>

    <p>Each triple generated from an <a href="#dfn-r2rml-mapping">R2RML
    mapping</a> is placed into one or
    more graphs of the <a href="#dfn-output-dataset">output dataset</a>.
    Possible target graphs are the unnamed
    <a href="#dfn-default-graph">default graph</a>, and the
    <a href="#dfn-iri">IRI</a>-named <a href="#dfn-named-graph">named
    graphs</a>.</p>

    <p>Any <a href="#dfn-subject-map">subject map</a>
    or <a href="#dfn-predicate-object-map">predicate-object map</a> <em class="rfc2119">MAY</em>
    have one or more associated <dfn id="dfn-graph-map">graph maps</dfn>.
    They are specified in one of two ways:</p>

    <ol>
    <li>using the <code>rr:graphMap</code> property, whose value
    <em class="rfc2119">MUST</em> be a
    <a href="#dfn-graph-map">graph map</a>,</li>
    <li>using the <a href="#dfn-constant-shortcut-property">constant
    shortcut property</a> <code>rr:graph</code>.</li>
    </ol>

    <p>Graph maps are themselves <a href="#dfn-term-map">term maps</a>.
    When <a href="#dfn-generating-rdf-triples">RDF
    triples are generated</a>, the set of target graphs is determined by
    taking into account any graph maps associated with the subject map
    or predicate-object map.</p>
    <p>If a <a href="#dfn-graph-map">graph map</a> generates the special
    IRI <code>rr:defaultGraph</code>, then the target graph is the
    <a href="#dfn-default-graph">default graph</a> of the
    <a href="#dfn-output-dataset">output dataset</a>.</p>

    <p>In the following <a href="#dfn-subject-map">subject map</a> example,
    all generated RDF triples will be stored in the named graph
    <code>ex:DepartmentGraph</code>.</p>
    <pre class="ex-mapping">
[] rr:subjectMap [
    rr:template "http://data.example.com/department/{DEPTNO}";
    rr:graphMap [ rr:constant ex:DepartmentGraph ];
].</pre>

    <p>This is equivalent to the following example, which uses a
    <a href="#dfn-constant-shortcut-property">constant shortcut property</a>:</p>

    <pre class="ex-mapping">
[] rr:subjectMap [
    rr:template "http://data.example.com/department/{DEPTNO}";
    rr:graph ex:DepartmentGraph;
].</pre>

    <p>In the following example, RDF triples are placed into named graphs
    according to the job title of employees:</p>

    <pre class="ex-mapping">
[] rr:subjectMap [
    rr:template "http://data.example.com/employee/{EMPNO}";
    rr:graphMap [ rr:template "http://data.example.com/jobgraph/{JOB}" ];
].</pre>

    <p>The triples generated from the <a href="#ex_EMP"><code>EMP</code>
    table</a> would be placed in the named graph with the following IRI:</p>

    <pre class="ex-output">
&lt;http://data.example.com/jobgraph/CLERK&gt;</pre>


    <h3 id="blank-nodes">9.1 Scope of Blank Nodes</h3>

    <p><a href="#dfn-blank-node">Blank nodes</a> in the
    <a href="#dfn-output-dataset">output dataset</a> are
    scoped to a single <a href="#dfn-rdf-graph">RDF graph</a>.
    If the same <a href="#dfn-blank-node-identifier">blank node identifier</a>
    occurs in multiple <a href="#dfn-rdf-triple">RDF triples</a>
    that are in the same graph, then the triples will share the
    same blank node.
    If, however, the same blank node identifier occurs in multiple graphs,
    then a distinct blank node be created for each graph. An R2RML-generated
    blank node can never be shared by two triples in two different graphs.</p>

    <p>This implies that triples generated from a single logical table row
    will have different subjects if the subjects are blank nodes and the
    triples are placed into different graphs.</p>


    <h2 id="datatype-conversions">10 Datatype Conversions</h2>
    
    <p>This section defines mappings from SQL data values to
    RDF <a href="#dfn-literal">literals</a>.</p>


    <h3 id="datatype-intro">10.1 Introduction (Informative)</h3>

    <p>This section defines the following mappings from SQL data values:</p>

    <ol>
    <li>The <strong><a href="#dfn-natural-rdf-literal">natural
    RDF literal</a></strong> 
    is a mapping to <a href="#dfn-literal">literals</a>.
    It is used in R2RML and in the
    <em><a href="http://www.w3.org/TR/rdb-direct-mapping/">Direct Mapping of
    Relational Data to RDF</a></em>
    [<cite><a href="#DM">DM</a></cite>] as the default mapping when literals
    are created. It maps SQL datatypes to corresponding XML Schema datatypes 
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>] and loosely
    follows <cite><em>ISO/IEC 9075-14:2008</em></cite>
    [<cite><a href="#SQL14">SQL14</a></cite>].</li>

    <li>The <strong><a href="#dfn-natural-rdf-lexical-form">natural
    RDF lexical form</a></strong>
    is similar, but produces only the lexical form of the typed literal
    and <em>recommends</em> that implementations perform XSD canonicalization.
    It is used in R2RML when <a href="#non-string-columns">non-string
    columns are used in a string context</a>, for example when a
    <code>TIMESTAMP</code> is used in an IRI
    <a href="#dfn-template-valued-term-map">template</a>.</li>

    <li>The <strong><a href="#dfn-canonical-rdf-lexical-form">canonical
    RDF lexical form</a></strong>
    is again similar, but <em>requires</em> XSD canonicalization. It is used in
    the Direct Mapping when IRIs are generated.</li>

    <li>The <strong><a href="#dfn-datatype-override-rdf-literal">datatype-override
    RDF literal</a></strong> is a mapping that constructs
    <a href="#dfn-typed-literal">typed literals</a> by using the
    <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>
    and applying a specified <a href="#dfn-datatype-iri">datatype IRI</a>.
    The mapping author is responsible for ensuring that the generated
    <a href="#dfn-lexical-form">lexical form</a> is valid for the datatype.
    It is used in R2RML when the target datatype of a literal-generating
    term map is overridden using
    <a href="#dfn-specified-datatype"><code>rr:datatype</code></a>.</li>
    </ol>

    <p>The mappings cover all predefined Core SQL 2008 datatypes except
    <code>INTERVAL</code>. The natural mappings may be
    <a href="#note-natural-mapping-extensions">extended with custom handling
    for other types</a>, such as vendor-specific
    SQL datatypes. In the absence of such extensions, the natural mappings
    fall back on a simple <a href="#dfn-cast-to-string">cast to string</a>
    for all unsupported SQL datatypes.</p>

    <p>The mappings are referenced in the R2RML
    <a href="#dfn-term-generation-rules">term generation rules</a>.</p>

    <p>An informative <a href="#xsd-summary">summary of XSD lexical forms</a>
    is provided to aid implementers.</p>

    
    <h3 id="natural-mapping">10.2 Natural Mapping of SQL Values</h3>

    <p>The <dfn id="dfn-natural-rdf-literal">natural RDF literal</dfn>
    corresponding to a SQL data value is the result of applying the
    following steps:</p>

    <ol>
    <li>Let <em>dt</em> be the SQL datatype of the SQL data value.</li>
    <li>If <em>dt</em> is a character string type (in Core SQL 2008:
    <code>CHARACTER</code>, <code>CHARACTER VARYING</code>, <code>CHARACTER
    LARGE OBJECT</code>, <code>NATIONAL CHARACTER</code>, <code>NATIONAL
    CHARACTER VARYING</code>, <code>NATIONAL CHARACTER LARGE OBJECT</code>),
    then the result is a
    <a href="#dfn-plain-literal">plain literal</a> without
    <a href="#dfn-language-tag">language tag</a> whose
    <a href="#dfn-lexical-form">lexical form</a> is the SQL data value.</li>
    <li>Otherwise, if <em>dt</em> is listed in the
    <a href="#table-type-mapping">table below</a>: The result is a
    <a href="#dfn-typed-literal">typed literal</a>
    whose <a href="#dfn-datatype-iri">datatype IRI</a> is the IRI indicated
    in the <em>RDF datatype</em> column in the same row as <em>dt</em>.
    The <a href="#dfn-lexical-form">lexical form</a> may be any lexical
    form that represents the same value as the SQL data value, according
    to the definition of the RDF datatype. If there are
    multiple lexical forms available that represent the same value
    (e.g., <code>1</code>, <code>+1</code>, <code>1.0</code> and
    <code>1.0E0</code>), then the choice is implementation-dependent.
    However, the choice <em class="rfc2119">MUST</em> be made so that
    given a target RDF datatype and value, the same lexical form
    is chosen consistently (e.g., <code>INTEGER 5</code> and
    <code>BIGINT 5</code> must be mapped to the same lexical form,
    as both are mapped to the RDF datatype <code>xsd:integer</code> and
    are equal values; mapping one to <code>5</code> and the other to
    <code>+5</code> would be an error). The
    <a href="http://www.w3.org/TR/xmlschema11-2/#dt-canonical-representation">canonical lexical representation</a>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>]
    <em class="rfc2119">MAY</em> be chosen.
    (See also: <a href="#xsd-summary">Summary of XSD Lexical Forms</a>)</li>
    <li>Otherwise, the result is a
    <a href="#dfn-plain-literal">plain literal</a> without
    <a href="#dfn-language-tag">language tag</a> whose
    <a href="#dfn-lexical-form">lexical form</a> is the SQL data value
    <a href="#dfn-cast-to-string">cast to string</a>.</li>
    </ol>

    <table id="table-type-mapping" rules="all" summary="Table of mappings between SQL datatypes and RDF datatypes">
    <tr>
      <th>SQL datatype</th>
      <th>RDF datatype</th>
      <th>Lexical transformation (informative)</th>
    </tr>
    <tr>
      <td><code>BINARY</code>, <code>BINARY VARYING</code>, <code>BINARY LARGE OBJECT</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary">xsd:hexBinary</a></code></td>
      <td><a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary"><code>xsd:hexBinary</code> lexical mapping</a></td>
    </tr>
    <tr>
      <td><code>NUMERIC</code>, <code>DECIMAL</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#decimal">xsd:decimal</a></code></td>
      <td>none required</td>
    </tr>
    <tr>
      <td><code>SMALLINT</code>, <code>INTEGER</code>, <code>BIGINT</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#integer">xsd:integer</a></code></td>
      <td>none required</td>
    </tr>
    <tr>
      <td><code>FLOAT</code>, <code>REAL</code>, <code>DOUBLE PRECISION</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#double">xsd:double</a></code></td>
      <td>none required</td>
    </tr>
    <tr>
      <td><code>BOOLEAN</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#boolean">xsd:boolean</a></code></td>
      <td>ensure lowercase (<code>true</code>, <code>false</code>)</td>
    </tr>
    <tr>
      <td><code>DATE</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#date">xsd:date</a></code></td>
      <td>none required</td>
    </tr>
    <tr>
      <td><code>TIME</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#time">xsd:time</a></code></td>
      <td>none required</td>
    </tr>
    <tr>
      <td><code>TIMESTAMP</code></td>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">xsd:dateTime</a></code></td>
      <td>replace space character with “<code>T</code>”</td>
    </tr>
    <tr>
      <td><code>INTERVAL</code></td>
      <td>undefined</td>
      <td>undefined</td>
    </tr>
    </table>

    <p class="note" id="note-natural-mapping-extensions">R2RML extensions
    that handle vendor-specific or user-defined datatypes
    beyond those of Core SQL 2008 are expected to behave as if
    the table above contained additional rows that associate the
    SQL datatypes with appropriate RDF-compatible datatypes
    (e.g., the
    <a href="http://www.w3.org/TR/xmlschema11-2/#built-in-datatypes">XML Schema built-in types</a>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>]),
    and appropriate lexical transformations where required.
    Note however that future versions of R2RML may also normatively
    add additional rows to this table.</p>

    <p class="note">The translation of <code>INTERVAL</code> is left
    undefined due to the complexity of the translation.
    [<cite><a href="#SQL14">SQL14</a></cite>] describes a translation of
    <code>INTERVAL</code> to <code>xdt:yearMonthDuration</code> and
    <code>xdt:dayTimeDuration</code>.</p>

    <p class="note">In [<cite><a href="#SQL2">SQL2</a></cite>],
    the precision of many SQL datatypes is not fixed, but left
    implementation-defined. Therefore, the mapping to XML Schema datatypes
    must rely on arbitrary-precision types such as
    <code>xsd:decimal</code>, <code>xsd:integer</code> and
    <code>xsd:dateTime</code>. Implementers of the mapping
    may wish to set upper limits for the supported precision of these XSD types.
    The XML Schema specification allows such <em><a href="http://www.w3.org/TR/xmlschema11-2/#partial-implementation">partial implementations of
    infinite datatypes</a></em> [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>],
    and defines specific minimum requirements.</p>

    <p>The <dfn id="dfn-natural-rdf-datatype">natural RDF datatype</dfn>
    corresponding to a SQL datatype is the value of the <em>RDF datatype</em>
    column in the row corresponding to the SQL datatype in the 
    <a href="#table-type-mapping">table above</a>.</p>

    <p>The <dfn id="dfn-natural-rdf-lexical-form">natural RDF lexical form</dfn>
    corresponding to a SQL data value is the
    <a href="#dfn-lexical-form">lexical form</a> of its corresponding
    <a href="#dfn-natural-rdf-literal">natural RDF literal</a>,
    with the additional constraint that the
    <a href="http://www.w3.org/TR/xmlschema11-2/#dt-canonical-representation">canonical lexical representation</a>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>]
    <em class="rfc2119">SHOULD</em> be chosen.</p>

    <p>The <dfn id="dfn-canonical-rdf-lexical-form">canonical RDF
    lexical form</dfn> corresponding to a SQL data value is the
    <a href="#dfn-lexical-form">lexical form</a> of its corresponding
    <a href="#dfn-natural-rdf-literal">natural RDF literal</a>,
    with the additional constraint that the
    <a href="http://www.w3.org/TR/xmlschema11-2/#dt-canonical-representation">canonical lexical representation</a>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>]
    <em class="rfc2119">MUST</em> be chosen.</p>

    <p><dfn id="dfn-cast-to-string">Cast to string</dfn> is an
    implementation-dependent function that maps SQL data values
    to equivalent Unicode strings. It is undefined for the following
    kinds of SQL datatypes:
    collection types, row types, user-defined types without a user-defined
    string <code>CAST</code>, reference types whose referenced type does
    not have a user-defined string <code>CAST</code>, binary types.</p>

    <p class="note"><a href="#dfn-cast-to-string">Cast to string</a>
    is a fallback that handles vendor-specific and user-defined datatypes
    not supported by the R2RML processor. It can be implemented in a number
    of ways, including explicit SQL casts (“<code>CAST(<em>value</em>
    AS VARCHAR(<em>n</em>))</code>”, where <em>n</em> is an arbitrary
    large integer), implicit SQL casts
    (concatenation with the empty string), or by employing a
    database access API that presents return values as strings.</p>


    <h3 id="datatype-overrides">10.3 Datatype-override Mapping of SQL Values</h3>

    <p>The <dfn id="dfn-datatype-override-rdf-literal">datatype-override
    RDF literal</dfn>
    corresponding to a SQL data value <em>v</em> and a
    <a href="#dfn-datatype-iri">datatype IRI</a> <em>dt</em>, is a
    <a href="#dfn-typed-literal">typed literal</a> whose lexical form is the
    <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>
    corresponding to <em>v</em>, and whose datatype IRI is <em>dt</em>.
    If the typed literal is <a href="#dfn-ill-typed">ill-typed</a>,
    then a <a href="#dfn-data-error">data error</a> is raised.</p>

    <p>A <a href="#dfn-typed-literal">typed literal</a> is
    <dfn id="dfn-ill-typed">ill-typed</dfn> in R2RML if its
    datatype IRI denotes a
    <a href="#dfn-validatable-rdf-datatype">validatable RDF datatype</a> 
    and its
    <a href="#dfn-lexical-form">lexical form</a> is not in the
    <a href="#dfn-lexical-space">lexical space</a> of the RDF datatype
    identified by its <a href="#dfn-datatype-iri">datatype IRI</a>.
    (See also: <a href="#xsd-summary">Summary of XSD Lexical Forms</a>)</p>

    <p>The set of
    <dfn id="dfn-validatable-rdf-datatype">validatable RDF datatypes</dfn>
    includes all datatypes in the <em>RDF datatype</em> column of the
    <a href="#table-type-mapping">table of natural datatype
    mappings</a>, as defined in
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>].
    This set <em class="rfc2119">MAY</em> include implementation-defined
    additional RDF datatypes.</p>

    <p>For example, <code>"X"^^xsd:boolean</code> is ill-typed because
    <code>xsd:boolean</code> is a validatable RDF datatype in R2RML, and
    “<code>X</code>” is not in the
    <a href="http://www.w3.org/TR/xmlschema11-2/#boolean">lexical space of
    <code>xsd:boolean</code></a>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>].</p>


    <h3 id="non-string-columns">10.4 Non-String Columns in String Contexts</h3>

    <p>The same non-character-string SQL data value can typically be
    represented in multiple different string forms. For example,
    the <code>DOUBLE</code> value 1 can be represented as
    <code>1</code>, <code>+1</code>, <code>1.0</code> and <code>1.0E0</code>.
    This can cause interoperability issues when such values
    are used in string contexts, for example when using them to generate
    <a href="#dfn-iri">IRIs</a>. Two IRIs that are character-for-character
    equivalent, except one contains <code>1</code> where the other
    contains <code>1.0</code>, will not “link up” in an RDF graph – they
    are two different nodes.</p>

    <p>To reduce portability issues arising from such conversions,
    this specification recommends that implementations convert non-string
    data values to a canonical form (see
    <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>).
    However, this is not a strict requirement. Therefore,
    when portability between R2RML implementations is a concern,
    mapping authors <em class="rfc2119">SHOULD NOT</em> use
    non-character-string columns in contexts where strings are produced:</p>

    <ul>
    <li>with <code>rr:column</code> when IRIs or blank nodes are
    produced,</li>
    <li>with <code>rr:column</code> when <code>rr:language</code>
    or an <code>rr:datatype</code> other than the
    <a href="#dfn-natural-rdf-datatype">natural RDF datatype</a> is used,
    and</li> <li>with <code>rr:template</code>.</li>
    </ul>

    <p>In these contexts, if portability is to be maximized, then
    mapping authors <em class="rfc2119">SHOULD</em> use an
    <a href="#dfn-r2rml-view">R2RML view</a> instead and explicitly
    convert the non-string column to a string column using
    an SQL expression.</p>

    <p>Note that this is not a problem when
    <a href="#dfn-natural-rdf-literal">natural RDF literals</a> are generated
    from such columns, because the resulting literal has a corresponding
    non-string XSD datatype, and equivalences between different lexical forms
    within these datatype are well-defined.</p>


    <h3 id="xsd-summary">10.5 Summary of XSD Lexical Forms (Informative)</h3>

    <p>The <a href="#natural-mapping">natural mappings</a> make reference to
    various XSD datatypes and require that SQL data values be converted
    to strings that are appropriate as lexical forms for these datatypes.
    This subsection gives examples of these lexical forms in order to
    aid implementers of the mappings. This subsection is non-normative;
    the normative definitions of the lexical spaces as well as the
    canonical lexical mappings are found in
    <em><a href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema
    Definition Language (XSD) 1.1 Part 2: Datatypes</a></em>
    [<cite><a href="#XMLSCHEMA2">XMLSCHEMA2</a></cite>].</p>

    <p>A general approach that may be used for implementing the
    natural mappings is as follows:</p>

    <ol>
    <li>Identify the SQL datatype of the input SQL data value.</li>
    <li>Look up its corresponding <a href="#dfn-natural-rdf-datatype">natural
    RDF datatype</a>.</li>
    <li>Apply <a href="#dfn-cast-to-string">cast to string</a> to the
    SQL data value.</li>
    <li>Ensure that the resulting string is in the lexical space of the
    target RDF datatype; that is, it must be in a form such as those listed
    in either column of the table below. This may require some transformations
    of the string, in particular for <code>xsd:hexBinary</code>,
    <code>xsd:dateTime</code> and <code>xsd:boolean</code>.</li>
    <li>If the goal is to obtain a canonical lexical representation, then
    further string transformations may be required to obtain a form such
    as those listed in the <em>Canonical lexical forms</em> column of the
    table below.</li>
    </ol>

    <table id="table-lexical-forms" rules="all" summary="Table of canonical and non-canonical lexical forms for some XSD datatypes">
    <tr>
      <th>RDF datatype</th>
      <th>Non-canonical lexical forms</th>
      <th>Canonical lexical forms</th>
      <th>Comments</th>
    </tr>
    <tr>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary">xsd:hexBinary</a></code></td>
      <td><code>5232524d4c</code></td>
      <td><code>5232524D4C</code></td>
      <td>Convert from SQL by applying <a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary"><code>xsd:hexBinary</code> lexical mapping</a>.</td>
    </tr>
    <tr>
      <td rowspan="4"><code><a href="http://www.w3.org/TR/xmlschema11-2/#decimal">xsd:decimal</a></code></td>
      <td><code>.224</code></td>
      <td><code>0.224</code></td>
      <td rowspan="4"></td>
    </tr>
    <tr>
      <td><code>+001</code></td>
      <td><code>1</code></td>
    </tr>
    <tr>
      <td><code>42.0</code></td>
      <td><code>42</code></td>
    </tr>
    <tr>
      <td><code>-5.9000</code></td>
      <td><code>-5.9</code></td>
    </tr>
    <tr>
      <td rowspan="3"><code><a href="http://www.w3.org/TR/xmlschema11-2/#integer">xsd:integer</a></code></td>
      <td><code>-05</code></td>
      <td><code>-5</code></td>
      <td rowspan="3"></td>
    </tr>
    <tr>
      <td><code>+333</code></td>
      <td><code>333</code></td>
    </tr>
    <tr>
      <td><code>00</code></td>
      <td><code>0</code></td>
    </tr>
    <tr>
      <td rowspan="5"><code><a href="http://www.w3.org/TR/xmlschema11-2/#double">xsd:double</a></code></td>
      <td><code>-5.90</code></td>
      <td><code>-5.9E0</code></td>
      <td rowspan="5">Also supports <code>INF</code>, <code>-INF</code>, <code>NaN</code> and <code>-0.0E0</code>,<br />but these do not appear in standard SQL.</td>
    </tr>
    <tr>
      <td><code>+0.00014770215000</code></td>
      <td><code>1.4770215E-4</code></td>
    </tr>
    <tr>
      <td><code>+01E+3</code></td>
      <td><code>1.0E3</code></td>
    </tr>
    <tr>
      <td><code>100.0</code></td>
      <td><code>1.0E2</code></td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>0.0E0</code></td>
    </tr>
    <tr>
      <td rowspan="2"><code><a href="http://www.w3.org/TR/xmlschema11-2/#boolean">xsd:boolean</a></code></td>
      <td><code>1</code></td>
      <td><code>true</code></td>
      <td rowspan="2">Must be lowercase.</td>
    </tr>
    <tr>
      <td><code>0</code></td>
      <td><code>false</code></td>
    </tr>
    <tr>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#date">xsd:date</a></code></td>
      <td></td>
      <td><code>2011-08-23</code></td>
      <td>Dates in SQL don't have timezone offsets.<br />They are optional in XSD.</td>
    </tr>
    <tr>
      <td rowspan="3"><code><a href="http://www.w3.org/TR/xmlschema11-2/#time">xsd:time</a></code></td>
      <td><code>22:17:34.885+00:00</code></td>
      <td><code>22:17:34.885Z</code></td>
      <td rowspan="3">May or may not have timezone offset.</td>
    </tr>
    <tr>
      <td><code>22:17:34.000</code></td>
      <td><code>22:17:34</code></td>
    </tr>
    <tr>
      <td><code>22:17:34.1+01:00</code></td>
      <td><code>22:17:34.1+01:00</code></td>
    </tr>
    <tr>
      <td><code><a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">xsd:dateTime</a></code></td>
      <td><code>2011-08-23T22:17:00.000+00:00</code></td>
      <td><code>2011-08-23T22:17:00Z</code></td>
      <td>May or may not have timezone offset.<br />Convert from SQL by replacing space wiht “<code>T</code>”.</td>
    </tr>
    </table>


    <h2 id="generated-rdf">11 The Output Dataset</h2>

    <p>The <dfn id="dfn-output-dataset">output dataset</dfn> of an
    R2RML mapping is an <a href="#dfn-rdf-dataset">RDF dataset</a>
    that contains the
    <a href="#dfn-generating-rdf-triples">generated RDF triples</a>
    for each of the <a href="#dfn-triples-map">triples maps</a> of
    the R2RML mapping. The output dataset <em class="rfc2119">MUST NOT</em>
    contain any other <a href="#dfn-rdf-triple">RDF triples</a> or
    <a href="#dfn-named-graph">named graphs</a> besides these.
    However, <a href="#dfn-r2rml-processor">R2RML processors</a>
    <em class="rfc2119">MAY</em> provide access to datasets that
    contain additional triples or graphs beyond those in the
    output dataset, such as inferred triples or provenance 
    information.</p>

    <p>If a table or column is not explicitly referenced in a
    <a href="#dfn-triples-map">triples map</a>,
    then no <a href="#dfn-rdf-triple">RDF triples</a>
    will be generated for that table or column.</p>

    <p>Conforming <a href="#dfn-r2rml-processor">R2RML processors</a>
    <em class="rfc2119">MAY</em> rename
    <a href="#dfn-blank-node">blank nodes</a> when providing
    access to the <a href="#dfn-output-dataset">output dataset</a>.
    This means that client applications may see actual
    <a href="#dfn-blank-node-identifier">blank node identifiers</a>
    that differ from those produced by the
    <a href="#dfn-r2rml-mapping">R2RML mapping</a>. Client applications
    <em class="rfc2119">SHOULD NOT</em>
    rely on the specific text of the blank node identifier for any purpose.</p>

    <p class="note" id="note-blank-node-identifiers">RDF syntaxes
    and RDF APIs generally represent
    <a href="#dfn-blank-node">blank nodes</a> with
    <a href="#dfn-blank-node-identifier">blank node identifiers</a>.
    But the characters allowed in blank node identifiers differ between
    syntaxes, and not all characters occurring in the values produced by
    a <a href="#dfn-term-map">term map</a> may be allowed, so a bijective
    mapping function from values to valid blank node identifiers may be
    required. The details of this mapping function are
    implementation-dependent, and 
    <a href="#dfn-r2rml-processor">R2RML processors</a> may have to use
    different functions for different output syntaxes or access interfaces.
    Strings matching the regular expression
    <code>[a-zA-Z_][a-zA-Z_0-9-]*</code> are valid blank node identifiers
    in all W3C-recommended RDF syntaxes (as of this document's publication).</p>

    <p class="note"><a href="#dfn-rdf-dataset">RDF datasets</a> may
    contain empty <a href="#dfn-named-graph">named graphs</a>.
    R2RML cannot generate such output datasets.</p>


    <h3 id="generated-triples">11.1 The Generated RDF Triples of a Triples Map</h3>

    <p>This subsection describes the process of
    <dfn id="dfn-generating-rdf-triples">generating RDF triples</dfn>
    from a <a href="#dfn-triples-map">triples map</a>. This process adds
    <a href="#dfn-rdf-triple">RDF triples</a> to the 
    <a href="#dfn-output-dataset">output dataset</a>. Each generated triple
    is placed into one or more graphs of the output dataset.</p>

    <p>The generated RDF triples are determined by the following algorithm.
    R2RML processors <em class="rfc2119">MAY</em> use other means than
    implementing this algorithm to compute the generated RDF triples,
    as long as the result is the same.</p>

    <ol>
    <li>Let <code><em>sm</em></code> be the
    <a href="#dfn-subject-map">subject map</a> of the triples map</li>
    <li>Let <code><em>rows</em></code> be the result of evaluating the
    <a href="#dfn-effective-sql-query">effective SQL query</a>
    of the <a href="#dfn-triples-map">triples map</a>'s
    <a href="#dfn-logical-table">logical table</a> using the
    <a href="#dfn-sql-connection">SQL connection</a></li>
    <li>Let <code><em>classes</em></code> be the
    <a href="#dfn-class-iri">class IRIs</a> of <code><em>sm</em></code></li>
    <li>Let <code><em>sgm</em></code> be the set of
    <a href="#dfn-graph-map">graph maps</a> of <code><em>sm</em></code></li>

    <li>For each <a href="#dfn-logical-table-row">logical table row</a>
    <code><em>row</em></code> in <code><em>rows</em></code>,
    apply the following steps:
      <ol>
      <li>Let <code><em>subject</em></code> be the
      <a href="#dfn-generated-rdf-term">generated RDF term</a> that results
      from applying <code><em>sm</em></code> to
      <code><em>row</em></code></li>
      <li>Let <code><em>subject_graphs</em></code> be the set of
      the <a href="#dfn-generated-rdf-term">generated RDF terms</a>
      that result from applying each term map in <code><em>sgm</em></code>
      to <code><em>row</em></code></li>
      <li>For each <code><em>class</em></code> in
      <code><em>classes</em></code>,
      <a href="#dfn-add-triples">add triples to the output dataset</a>
      as follows:
        <p>
        <strong>Subject:</strong> <code><em>subject</em></code><br />
        <strong>Predicate:</strong> <code>rdf:type</code><br />
        <strong>Object:</strong> <code><em>class</em></code><br />
        <strong>Target graphs:</strong> If <code><em>sgm</em></code> is empty:
          <code>rr:defaultgraph</code>;
          otherwise: <code><em>subject_graphs</em></code>
        </p>
      </li>
      <li>For each <a href="#dfn-predicate-object-map">predicate-object map</a>
      of the <a href="#dfn-triples-map">triples map</a>, apply the following
      steps:
        <ol>
        <li>Let <code><em>predicates</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a> that result
        from applying each of the predicate-object map's
        <a href="#dfn-predicate-map">predicate maps</a>
        to <code><em>row</em></code></li>
        <li>Let <code><em>objects</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a> that result
        from applying each of the predicate-object map's
        <a href="#dfn-object-map">object maps</a> (but not
        <a href="#dfn-referencing-object-map">referencing object maps</a>)
        to <code><em>row</em></code></li>
        <li>Let <code><em>pogm</em></code> be the set of 
        <a href="#dfn-graph-map">graph maps</a> of the predicate-object map</li>
        <li>Let <code><em>predicate-object_graphs</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a>
        that result from applying each <a href="#dfn-graph-map">graph map</a>
        in <code><em>pogm</em></code> to <code><em>row</em></code></li>
        <li>For each possible combination &lt;<code><em>predicate</em></code>,
        <code><em>object</em></code>&gt;
        where <code><em>predicate</em></code> is a member of
        <code><em>predicates</em></code> and <code><em>object</em></code>
        is a member of <code><em>objects</em></code>,
        <a href="#dfn-add-triples">add triples to the output dataset</a>
        as follows:
          <p>
          <strong>Subject:</strong> <code><em>subject</em></code><br />
          <strong>Predicate:</strong> <code><em>predicate</em></code><br />
          <strong>Object:</strong> <code><em>object</em></code><br />
          <strong>Target graphs:</strong> If <code><em>sgm</em></code> and
          <code><em>pogm</em></code> are empty: <code>rr:defaultGraph</code>;
          otherwise: union of <code><em>subject_graphs</em></code>
          and <code><em>predicate-object_graphs</em></code>
          </p>
        </li>
        </ol>
      </li>
      </ol>
    </li>
    <li>For each <a href="#dfn-referencing-object-map">referencing object map</a>
    of a <a href="#dfn-predicate-object-map">predicate-object map</a> 
    of the <a href="#dfn-triples-map">triples map</a>, apply the following
    steps:
      <ol>
      <li>Let <code><em>psm</em></code> be the
      <a href="#dfn-subject-map">subject map</a> of the
      <a href="#dfn-parent-triples-map">parent triples map</a> of the
      referencing object map</li>
      <li>Let <code><em>pogm</em></code> be the set of 
      <a href="#dfn-graph-map">graph maps</a> of the predicate-object map</li>
      <li>Let <code><em>n</em></code> be the number of columns
      in the logical table of the
      <a href="#dfn-triples-map">triples map</a></li>
      <li>Let <code><em>rows</em></code> be the result of evaluating the
      <a href="#dfn-joint-sql-query">joint SQL query</a>
      of the referencing object map</li>
      <li>For each <code><em>row</em></code> in <code><em>rows</em></code>,
      apply the following steps:
        <ol>
        <li>Let <code><em>child_row</em></code> be the logical table row
        derived by taking the first <code><em>n</em></code> columns of
        <code><em>row</em></code></li>
        <li>Let <code><em>parent_row</em></code> be the logical table row
        derived by taking all but the first <code><em>n</em></code> columns of
        <code><em>row</em></code></li>
        <li>Let <code><em>subject</em></code> be the
        <a href="#dfn-generated-rdf-term">generated RDF term</a> that results
        from applying <code><em>sm</em></code> to
        <code><em>child_row</em></code></li>
        <li>Let <code><em>predicates</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a> that result
        from applying each of the predicate-object map's
        <a href="#dfn-predicate-map">predicate maps</a>
        to <code><em>child_row</em></code></li>
        <li>Let <code><em>object</em></code> be the
        <a href="#dfn-generated-rdf-term">generated RDF term</a> that results
        from applying <code><em>psm</em></code> to
        <code><em>parent_row</em></code></li>
        <li>Let <code><em>subject_graphs</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a>
        that result from applying each
        <a href="#dfn-graph-map">graph map</a> of <code><em>sgm</em></code>
        to <code><em>child_row</em></code></li>
        <li>Let <code><em>predicate-object_graphs</em></code> be the set of
        <a href="#dfn-generated-rdf-term">generated RDF terms</a>
        that result from applying each
        <a href="#dfn-graph-map">graph map</a> in <code><em>pogm</em></code>
        to <code><em>child_row</em></code></li>
        <li>For each <code><em>predicate</em></code>
        in <code><em>predicates</em></code>,
        <a href="#dfn-add-triples">add triples to the output dataset</a>
        as follows:
          <p>
          <strong>Subject:</strong> <code><em>subject</em></code><br />
          <strong>Predicate:</strong> <code><em>predicate</em></code><br />
          <strong>Object:</strong> <code><em>object</em></code><br />
          <strong>Target graphs:</strong> If neither <code><em>sgm</em></code>
          nor <code><em>pogm</em></code> has any <a href="#dfn-graph-map">graph
          maps</a>: <code>rr:defaultGraph</code>; otherwise: union of
          <code><em>subject_graphs</em></code>
          and <code><em>predicate-object_graphs</em></code>
          </p>
        </li>
        </ol>
      </li>
      </ol>
    </li>
    </ol>

    <p>“<dfn id="dfn-add-triples">Add triples
    to the output dataset</dfn>” is a process that takes the following
    inputs:</p>

    <ul>
    <li><strong>Subject</strong>, an
    <a href="#dfn-iri">IRI</a> or
    <a href="#dfn-blank-node">blank node</a> or <em>empty</em></li>
    <li><strong>Predicate</strong>, an
    <a href="#dfn-iri">IRI</a> or <em>empty</em></li>
    <li><strong>Object</strong>, an
    <a href="#dfn-rdf-term">RDF term</a> or <em>empty</em></li>
    <li><strong>Target graphs</strong>, a set of zero or more
    <a href="#dfn-iri">IRIs</a></li>
    </ul>

    <p>Execute the following steps:</p>

    <ol>
    <li>If <em>Subject</em>, <em>Predicate</em> or <em>Object</em>
    is <em>empty</em>, then abort these steps.</li>
    <li>Otherwise, generate an <a href="#dfn-rdf-triple">RDF triple</a>
    &lt;<em>Subject</em>, <em>Predicate</em>, <em>Object</em>&gt;</li>
    <li>If the set of target graphs includes <code>rr:defaultGraph</code>,
    add the triple to the <a href="#dfn-default-graph">default graph</a>
    of the <a href="#dfn-output-dataset">output dataset</a>.</li>
    <li>For each <a href="#dfn-iri">IRI</a> in the set of target
    graphs that is not equal to <code>rr:defaultGraph</code>,
    add the triple to a <a href="#dfn-default-graph">named graph</a>
    of that name in the <a href="#dfn-output-dataset">output dataset</a>.
    If the output dataset does not contain a named graph with that IRI,
    create it first.</li>
    </ol>

    <p><a href="#dfn-rdf-graph">RDF graphs</a> cannot contain duplicate
    <a href="#dfn-rdf-triple">RDF triples</a>. Placing multiple equal
    triples into the same graph has the same effect as placing it into
    the graph only once. Also note the <a href="#blank-nodes">scope of
    blank nodes</a>.</p>


    <h3 id="generated-rdf-term">11.2 The Generated RDF Term of a Term Map</h3>

    <p>A <a href="#dfn-term-map">term map</a> is a function that generates
    an <a href="#dfn-rdf-term">RDF term</a> from a
    <a href="#dfn-logical-table-row">logical table row</a>. The result of that
    function can be:</p>

    <ul>
      <li><em>Empty</em> – if any of the
      <a href="#dfn-referenced-columns">referenced columns</a> of the
      term map has a <code>NULL</code> value,</li>
      <li>An RDF term – the common case,</li>
      <li>A <a href="#dfn-data-error">data error</a>.</li>
    </ul>

    <p>The <dfn id="dfn-generated-rdf-term">generated RDF term</dfn> 
    of a term map for a given logical table row is determined as follows:</p>

    <ul>
    <li>If the term map is a
    <a href="#dfn-constant-valued-term-map">constant-valued term map</a>,
    then the generated RDF term is
    the term map's <a href="#dfn-constant-value">constant value</a>.</li>

    <li>If the term map is a
    <a href="#dfn-column-valued-term-map">column-valued term map</a>, then
    the generated RDF term is determined by applying the
    <a href="#dfn-term-generation-rules">term generation rules</a> to its
    <a href="#dfn-column-value">column value</a>.</li>

    <li>If the term map is a
    <a href="#dfn-template-valued-term-map">template-valued term map</a>, then
    the generated RDF term is determined by applying the
    <a href="#dfn-term-generation-rules">term generation rules</a> to its
    <a href="#dfn-template-value">template value</a>.</li>
    </ul>

    <p>The <dfn id="dfn-term-generation-rules">term generation rules</dfn>,
    applied to a <em>value</em>, are as follows:</p>

    <ol>
    <li>If <em>value</em> is <code>NULL</code>, then no RDF term
    is generated.</li>
    <li>Otherwise, if the <a href="#dfn-term-map">term map</a>'s
    <a href="#dfn-term-type">term type</a> is <code>rr:IRI</code>:
      <ol>
      <li>Let <em>value</em> be the
      <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>
      corresponding to <em>value</em>.</li>
      <li>If <em>value</em> is a valid
      <cite><a href="http://tools.ietf.org/html/rfc3987#section-2.2">
      absolute IRI</a></cite> [<cite><a href="#RFC3987">RFC3987</a></cite>],
      then return an <a href="#dfn-iri">IRI</a> generated from
      <em>value</em>.</li>
      <li>Otherwise, prepend <em>value</em> with the
      <a href="#dfn-base-iri">base IRI</a>. If the result is a valid
      <cite><a href="http://tools.ietf.org/html/rfc3987#section-2.2">
      absolute IRI</a></cite> [<cite><a href="#RFC3987">RFC3987</a></cite>],
      then return an <a href="#dfn-iri">IRI</a> generated from the result.</li>
      <li>Otherwise, raise a <a href="#dfn-data-error">data error</a>.</li>
      </ol>
    </li>
    <li>Otherwise, if the term type is <code>rr:BlankNode</code>:
      <ol>
      <li>Return a <a href="#dfn-blank-node-identifier">blank node</a> that
      is unique to the 
      <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>
      corresponding to <em>value</em>. (Note: 
      <a href="#note-blank-node-identifiers">On Blank Node Identifiers</a>,
      <a href="#blank-nodes">Scope of Blank Nodes</a>)</li>
      </ol>
    </li>
    <li>Otherwise, if the term type is <code>rr:Literal</code>:
      <ol>
      <li>If the term map has a <a href="#dfn-specified-language-tag">specified
      language tag</a>, then return a
      <a href="#dfn-plain-literal">plain literal</a> with that language tag
      and with the 
      <a href="#dfn-natural-rdf-lexical-form">natural RDF lexical form</a>
      corresponding to <em>value</em>.</li>
      <li>Otherwise, if the term map has a non-empty
      <a href="#dfn-specified-datatype">specified datatype</a> that is
      different from the
      <a href="#dfn-natural-rdf-datatype">natural RDF datatype</a>
      corresponding to the term map's
      <a href="#dfn-implicit-sql-datatype">implicit SQL datatype</a>, then
      return the <a href="#dfn-datatype-override-rdf-literal">datatype-override
      RDF literal</a> corresponding to <em>value</em> and the
      specified datatype.</li>
      <li>Otherwise, return the
      <a href="#dfn-natural-rdf-literal">natural RDF literal</a>
      corresponding to <em>value</em>.</li>
      </ol>
    </li>
    </ol>


    <h2 id="terminology">A. RDF Terminology (Informative)</h2>

    <p>This appendix lists some terms normatively defined in other specifications.</p>

    <p>The following terms are defined in <cite><em><a class="norm" href=
    "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF Concepts and Abstract
    Syntax</a></em></cite> [<cite><a href="#RDF">RDF</a></cite>] and used in R2RML:</p>

    <ul>
      <li><dfn id="dfn-rdf-graph"><a class="type rdfGraph" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-rdf-graph">RDF
      graph</a></dfn></li>

      <li><dfn id="dfn-rdf-triple"><a href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-rdf-triple">RDF
      triple</a></dfn></li>

      <li><dfn id="dfn-iri"><a class="type IRI" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</a></dfn>
      (corresponds to the Concepts and Abstract Syntax term <em>RDF URI
      reference</em>)</li>

      <li><dfn id="dfn-literal"><a class="type literal" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">literal</a></dfn></li>

      <li><dfn id="dfn-plain-literal"><a class="type plainLiteral" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">plain
      literal</a></dfn></li>

      <li><dfn id="dfn-typed-literal"><a class="type typedLiteral" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">typed
      literal</a></dfn></li>

      <li><dfn id="dfn-language-tag"><a class="type langTag" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-language-identifier">language
      tag</a></dfn></li>

      <li><dfn id="dfn-lexical-form"><a class="type lexicalForm" href=
      "http://www.w3.org/TR/rdf-concepts/#dfn-lexical-form">lexical form</a></dfn></li>

      <li><dfn id="dfn-datatype-iri"><a class="type datatypeIRI" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-datatype-URI">datatype
      IRI</a></dfn> (corresponds to the Concepts and Abstract Syntax term <em>datatype
      URI</em>)</li>

      <li><dfn id="dfn-lexical-space"><a class="type lexicalSpace" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-lexical-space">lexical space</a></dfn></li>

      <li><dfn id="dfn-blank-node"><a class="type bNode" href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank
      node</a></dfn></li>

      <li><dfn id="dfn-blank-node-identifier"><a href=
      "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node-id">
      blank node identifier</a></dfn></li>
    </ul>

    <p>The following terms are defined in <cite><em><a class="norm" href=
    "http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for
    RDF</a></em></cite> [<cite><a href="#SPARQL">SPARQL</a></cite>] and used in
    R2RML:</p>

    <ul>
      <li><dfn id="dfn-rdf-dataset"><a href=
      "http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/#rdfDataset">RDF
      dataset</a></dfn></li>

      <li><dfn id="dfn-default-graph"><a href=
      "http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/#rdfDataset">default
      graph</a></dfn></li>

      <li><dfn id="dfn-named-graph"><a href=
      "http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/#rdfDataset">named
      graph</a></dfn></li>
    </ul>


    <h2 id="index">B. Index of R2RML Vocabulary Terms (Informative)</h2>

    <p>This appendix lists all the classes, properties and other terms
    defined by this specification within the
    <a href="#dfn-r2rml-vocabulary">R2RML vocabulary</a>.</p>

    <p>An RDFS representation of the vocabulary is available from
    the <a href="http://www.w3.org/ns/r2rml#">namespace IRI</a>.</p>


    <h3 id="class-index">B.1 Classes</h3>

    <p>The following table lists all <a href="#dfn-r2rml-classes">R2RML classes</a>.</p>

    <p>The third column contains minimum conditions that a resource
    has to fulfil in order to be considered member of the class.
    Where multiple conditions are listed, all must be fulfilled.</p>

    <table class="term-index">
      <tr><th>Class</th><th>Represents</th><th>Minimum conditions</th></tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#BaseTableOrView"><code>rr:BaseTableOrView</code></a></th>
        <td><a href="#dfn-sql-base-table-or-view">SQL base table or view</a></td>
        <td>Having an <code>rr:tableName</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#GraphMap"><code>rr:GraphMap</code></a></th>
        <td><a href="#dfn-graph-map">graph map</a></td>
        <td>Being an <code>rr:TermMap</code><br />
          Being value of an <code>rr:graphMap</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#Join"><code>rr:Join</code></a></th>
        <td><a href="#dfn-join-condition">join condition</a></td>
        <td>Having an <code>rr:parent</code> property<br />
          Having an <code>rr:child</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#LogicalTable"><code>rr:LogicalTable</code></a></th>
        <td><a href="#dfn-logical-table">logical table</a></td>
        <td>Being one of its subclasses, <code>rr:BaseTableOrView</code> or <code>rr:R2RMLView</code></td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#ObjectMap"><code>rr:ObjectMap</code></a></th>
        <td><a href="#dfn-object-map">object map</a></td>
        <td>Being an <code>rr:TermMap</code><br />
          Being value of an <code>rr:objectMap</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#PredicateMap"><code>rr:PredicateMap</code></a></th>
        <td><a href="#dfn-predicate-map">predicate map</a></td>
        <td>Being an <code>rr:TermMap</code><br />
          Being value of an <code>rr:predicateMap</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#PredicateObjectMap"><code>rr:PredicateObjectMap</code></a></th>
        <td><a href="#dfn-predicate-object-map">predicate-object map</a></td>
        <td>Having at least one of <code>rr:predicate</code> and <code>rr:predicateMap</code><br />
          Having at least one of <code>rr:object</code> and <code>rr:objectMap</code></td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#R2RMLView"><code>rr:R2RMLView</code></a></th>
        <td><a href="#dfn-r2rml-view">R2RML view</a></td>
        <td>Having an <code>rr:sqlQuery</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#RefObjectMap"><code>rr:RefObjectMap</code></a></th>
        <td><a href="#dfn-referencing-object-map">referencing object map</a></td>
        <td>Having an <code>rr:parentTriplesMap</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#SubjectMap"><code>rr:SubjectMap</code></a></th>
        <td><a href="#dfn-subject-map">subject map</a></td>
        <td>Being an <code>rr:TermMap</code><br />
          Being value of an <code>rr:subjectMap</code> property</td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#TermMap"><code>rr:TermMap</code></a></th>
        <td><a href="#dfn-term-map">term map</a></td>
        <td>Having exactly one of <code>rr:constant</code>, <code>rr:column</code>, <code>rr:template</code></td>
      </tr>
      <tr>
        <th><a href="http://www.w3.org/ns/r2rml#TriplesMap"><code>rr:TriplesMap</code></a></th>
        <td><a href="#dfn-triples-map">triples map</a></td>
        <td>Having an <code>rr:logicalTable</code> property<br />
          Having exactly one of <code>rr:subject</code> and <code>rr:subjectMap</code></td>
      </tr>
    </table>

    <p>As <a href="#vocabulary">noted earlier</a>, a single node in an
    <a href="#dfn-r2rml-mapping-graph">R2RML mapping graph</a> may represent
    multiple mapping components and thus be typed as several of these
    classes. However, the following classes are disjoint:</p>

    <ul>
    <li><code>rr:TermMap</code> and <code>rr:RefObjectMap</code></li>
    <li><code>rr:BaseTableOrView</code> and <code>rr:SQLQuery</code></li>
    <li><a href="#dfn-constant-valued-term-map">constant-valued</a>,
    <a href="#dfn-column-valued-term-map">column-valued</a> and
    <a href="#dfn-template-valued-term-map">template valued</a> term
    maps (indicated by the presence of the properties
    <code>rr:constant</code>, <code>rr:column</code> and <code>rr:template</code>,
    respectively)</li>
    </ul>


    <h3 id="property-index">B.2 Properties</h3>

    <p>The following table lists all properties in the
    <a href="#dfn-r2rml-vocabulary">R2RML vocabulary</a>.</p>

    <p>The cardinality column indicates how often this property
    occurs within its context. Note that additional constraints
    not stated in this table might apply. The actual
    cardinality of some properties may depend on the presence
    or absence of other properties, and their values.
    Properties where this applies are indicated by an exclamation
    mark.</p>

    <table class="term-index">
      <tr><th>Property</th><th>Represents</th><th>Context</th><th colspan="2">Cardinality</th></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#child"><code>rr:child</code></a></th>
        <td><a href="#dfn-child-column">child column</a></td>
        <td><a href="#dfn-join-condition">join condition</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#class"><code>rr:class</code></a></th>
        <td><a href="#dfn-class-iri">class IRI</a></td>
        <td><a href="#dfn-subject-map">subject map</a></td>
        <td>0…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#column"><code>rr:column</code></a></th>
        <td><a href="#dfn-column-valued-term-map">column name</a></td>
        <td><a href="#dfn-column-valued-term-map">column-valued term map</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#datatype"><code>rr:datatype</code></a></th>
        <td><a href="#dfn-specified-datatype">specified datatype</a></td>
        <td><a href="#dfn-term-map">term map</a></td>
        <td>0…1</td><td>!</td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#constant"><code>rr:constant</code></a></th>
        <td><a href="#dfn-constant-value">constant value</a></td>
        <td><a href="#dfn-constant-valued-term-map">constant-valued term map</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#graph"><code>rr:graph</code></a></th>
        <td><a href="#dfn-constant-shortcut-property">constant shortcut property</a></td>
        <td rowspan="2"><a href="#dfn-subject-map">subject map</a>, <a href="#dfn-predicate-object-map">predicate-object map</a></td>
        <td rowspan="2">0…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#graphMap"><code>rr:graphMap</code></a></th>
        <td><a href="#dfn-graph-map">graph map</a></td>
        <td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#inverseExpression"><code>rr:inverseExpression</code></a></th>
        <td><a href="#dfn-inverse-expression">inverse expression</a></td>
        <td><a href="#dfn-term-map">term map</a></td>
        <td>0…1</td><td>!</td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#joinCondition"><code>rr:joinCondition</code></a></th>
        <td><a href="#dfn-join-condition">join condition</a></td>
        <td><a href="#dfn-referencing-object-map">referencing object map</a></td>
        <td>0…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#language"><code>rr:language</code></a></th>
        <td><a href="#dfn-specified-language-tag">specified language tag</a></td>
        <td><a href="#dfn-term-map">term map</a></td>
        <td>0…1</td><td>!</td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#logicalTable"><code>rr:logicalTable</code></a></th>
        <td><a href="#dfn-triples-map">logical table</a></td>
        <td><a href="#dfn-triples-map">triples map</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#object"><code>rr:object</code></a></th>
        <td><a href="#dfn-constant-shortcut-property">constant shortcut property</a></td>
        <td rowspan="2"><a href="#dfn-predicate-object-map">predicate-object map</a></td>
        <td rowspan="2">1…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#objectMap"><code>rr:objectMap</code></a></th>
        <td><a href="#dfn-object-map">object map</a>, <a href="#dfn-referencing-object-map">referencing object map</a></td>
        <td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#parent"><code>rr:parent</code></a></th>
        <td><a href="#dfn-parent-column">parent column</a></td>
        <td><a href="#dfn-join-condition">join condition</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#parentTriplesMap"><code>rr:parentTriplesMap</code></a></th>
        <td><a href="#dfn-parent-triples-map">parent triples map</a></td>
        <td><a href="#dfn-referencing-object-map">referencing object map</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#predicate"><code>rr:predicate</code></a></th>
        <td><a href="#dfn-constant-shortcut-property">constant shortcut property</a></td>
        <td rowspan="2"><a href="#dfn-predicate-object-map">predicate-object map</a></td>
        <td rowspan="2">1…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#predicateMap"><code>rr:predicateMap</code></a></th>
        <td><a href="#dfn-predicate-map">predicate map</a></td>
        <td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#predicateObjectMap"><code>rr:predicateObjectMap</code></a></th>
        <td><a href="#dfn-triples-map">predicate-object map</a></td>
        <td><a href="#dfn-triples-map">triples map</a></td>
        <td>0…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#sqlQuery"><code>rr:sqlQuery</code></a></th>
        <td><a href="#dfn-sql-query">SQL query</a></td>
        <td><a href="#dfn-r2rml-view">R2RML view</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#sqlVersion"><code>rr:sqlVersion</code></a></th>
        <td><a href="#dfn-sql-version-identifier">SQL version identifier</a></td>
        <td><a href="#dfn-r2rml-view">R2RML view</a></td>
        <td>0…∞</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#subject"><code>rr:subject</code></a></th>
        <td><a href="#dfn-constant-shortcut-property">constant shortcut property</a></td>
        <td rowspan="2"><a href="#dfn-triples-map">triples map</a></td>
        <td rowspan="2">0…1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#subjectMap"><code>rr:subjectMap</code></a></th>
        <td><a href="#dfn-triples-map">subject map</a></td>
        <td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#tableName"><code>rr:tableName</code></a></th>
        <td><a href="#dfn-table-or-view-name">table or view name</a></td>
        <td><a href="#dfn-sql-base-table-or-view">SQL base table or view</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#template"><code>rr:template</code></a></th>
        <td><a href="#dfn-string-template">string template</a></td>
        <td><a href="#dfn-template-valued-term-map">template-valued term map</a></td>
        <td>1</td><td></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#termType"><code>rr:termType</code></a></th>
        <td><a href="#dfn-term-type">term type</a></td>
        <td><a href="#dfn-term-map">term map</a></td>
        <td>0…1</td><td>!</td></tr>
    </table>


    <h3 id="other-index">B.3 Other Terms</h3>

    <table class="term-index">
      <tr><th>Term</th><th>Denotes</th><th>Used with property</th></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#defaultGraph"><code>rr:defaultGraph</code></a></th>
        <td><a href="#dfn-default-graph">default graph</a></td>
        <td><a href="#named-graphs"><code>rr:graph</code></a></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#SQL2008"><code>rr:SQL2008</code></a></th>
        <td><a href="#conformance">Core SQL 2008</a></td>
        <td><a href="#dfn-sql-version-identifier"><code>rr:sqlVersion</code></a></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#IRI"><code>rr:IRI</code></a></th>
        <td><a href="#dfn-iri">IRI</a></td>
        <td><a href="#dfn-term-type"><code>rr:termType</code></a></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#BlankNode"><code>rr:BlankNode</code></a></th>
        <td><a href="#dfn-blank-node">blank node</a></td>
        <td><a href="#dfn-term-type"><code>rr:termType</code></a></td></tr>
      <tr><th><a href="http://www.w3.org/ns/r2rml#Literal"><code>rr:Literal</code></a></th>
        <td><a href="#dfn-literal">literal</a></td>
        <td><a href="#dfn-term-type"><code>rr:termType</code></a></td></tr>
    </table>


    <h2 id="references">C. References</h2>

    <h3 id="normative-refs">C.1 Normative References</h3>

    <dl>
      <dt><a id="DM" name="DM">[DM]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2012/REC-rdb-direct-mapping-20120927/">A
      Direct Mapping of Relational Data to RDF</a></cite>, Alexandre Bertails, Marcelo Arenas,
      Eric Prud'hommeaux, Juan Sequeda, Editors. World Wide Web Consortium, 27 September 2012.
      This version is http://www.w3.org/TR/2012/REC-rdb-direct-mapping-20120927/. The latest
      version is http://www.w3.org/TR/rdb-direct-mapping/.</dd>

      <dt><a id="RDF" name="RDF">[RDF]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource
      Description Framework (RDF): Concepts and Abstract Syntax</a></cite>, Graham Klyne,
      Jermey J. Carroll, Editors. World Wide Web Consortium, 10 February 2004. This
      version is http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/. The latest version
      is http://www.w3.org/TR/rdf-concepts/.</dd>

      <dt><a id="RFC2119" name="RFC2119">[RFC2119]</a></dt>

      <dd><cite><a href="http://tools.ietf.org/html/rfc2119">Key words
      for use in RFCs to Indicate Requirement Levels</a></cite>, S. Bradner,
      March 1997.
      Internet RFC 2119, http://tools.ietf.org/html/rfc2119.</dd> 

      <dt><a id="RFC3629" name="RFC3629">[RFC3629]</a></dt>

      <dd><cite><a href="http://tools.ietf.org/html/rfc3629">UTF-8, a
      transformation format of ISO 10646</a></cite>, F. Yergeau. November 2003.
      Internet RFC 3629, http://tools.ietf.org/html/rfc3629.</dd> 

      <dt><a id="RFC3986" name="RFC3986">[RFC3986]</a></dt>

      <dd><cite><a href="http://tools.ietf.org/html/rfc3986">Uniform Resource
      Identifier (URI): Generic Syntax</a></cite>, T. Berners-Lee, R. Fielding,
      L. Masinter. January 2005.
      Internet RFC 3986, http://tools.ietf.org/html/rfc3986.</dd> 

      <dt><a id="RFC3987" name="RFC3987">[RFC3987]</a></dt>

      <dd><cite><a href="http://tools.ietf.org/html/rfc3987">Internationalized
      Resource Identifiers (IRIs)</a></cite>, M. Duerst, M. Suignard.  January 2005.
      Internet RFC 3987, http://tools.ietf.org/html/rfc3987.</dd> 

      <dt><a id="SPARQL" name="SPARQL">[SPARQL]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL
      Query Language for RDF</a></cite>, Eric Prud'hommeaux, Andy Seaborne, Editors.
      World Wide Web Consortium, 15 January 2008. This version is
      http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/. The latest version is
      http://www.w3.org/TR/rdf-sparql-query/.</dd>

      <dt><a id="SQL1" name="SQL1">[SQL1]</a></dt>

      <dd><cite>ISO/IEC 9075-1:2008 SQL - Part 1: Framework (SQL/Framework)</cite>.
      International Organization for
      Standardization, 27 January 2009.</dd>

      <dt><a id="SQL2" name="SQL2">[SQL2]</a></dt>

      <dd><cite>ISO/IEC 9075-2:2008 SQL - Part 2: Foundation (SQL/Foundation)</cite>.
      International Organization for
      Standardization, 27 January 2009.</dd>

      <dt><a id="TURTLE" name="TURTLE">[TURTLE]</a></dt>

      <dd><cite><a href=
      "http://www.w3.org/TR/2012/WD-turtle-20120710/">Turtle - Terse RDF
      Triple Language</a></cite>, Eric Prud'hommeaux, Gavin Carothers.
      World Wide Web Consortium, 10 July 2012. This version is
      http://www.w3.org/TR/2012/WD-turtle-20120710/. The latest version is
      http://www.w3.org/TR/turtle/. This document is work in progress.</dd>

      <dt><a id="XMLSCHEMA2" name="XMLSCHEMA2">[XMLSCHEMA2]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>,
      David Peterson, Shudi Gao, Ashok Malhotra, C. M. Sperberg-McQueen,
      Henry S. Thompson. World Wide Web Consortium,
      5 April 2012. This version is
      http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/.
      The latest version is http://www.w3.org/TR/xmlschema11-2/.</dd>
    </dl>


    <h3 id="non-normative-refs">C.2 Other References</h3>

    <dl>
      <dt><a id="SQL14" name="SQL14">[SQL14]</a></dt>

      <dd><cite>ISO/IEC 9075-14:2008 SQL - Part 14: XML-Related Specifications (SQL/XML)</cite>.
      International Organization for Standardization, 27 January 2009.</dd>

      <dt><a id="SQLIRIS" name="SQLIRIS">[SQLIRIS]</a></dt>

      <dd><cite><a href="http://www.w3.org/2001/sw/wiki/RDB2RDF/SQL_Version_IRIs">SQL
      Version IRIs</a></cite>, Editors of the W3C Semantic Web Standards wiki.
      The latest version is http://www.w3.org/2001/sw/wiki/RDB2RDF/SQL_Version_IRIs.
      This is a public wiki page.</dd>

      <dt><a id="TC" name="TC">[TC]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2012/NOTE-rdb2rdf-test-cases-20120814/">R2RML and Direct Mapping Test Cases</a></cite>, Boris Villaz&oacute;n-Terrazas, Michael Hausenblas, Editors. World Wide Web Consortium, 14 August 2012. This version is http://www.w3.org/TR/2012/NOTE-rdb2rdf-test-cases-20120814/. The latest version is http://www.w3.org/TR/rdb2rdf-test-cases/.</dd>

      <dt><a id="UCNR" name="UCNR">[UCNR]</a></dt>

      <dd><cite><a href="http://www.w3.org/TR/2010/WD-rdb2rdf-ucr-20100608/">Use Cases
      and Requirements for Mapping Relational Databases to RDF</a></cite>, Eric
      Prud'hommeaux, Michael Hausenblas, Editors. World Wide Web Consortium, 8 June 2010.
      This version is http://www.w3.org/TR/2010/WD-rdb2rdf-ucr-20100608/. The latest
      version is http://www.w3.org/TR/rdb2rdf-ucr/. This document is work in
      progress.</dd>
    </dl>


    <h2 id="acknowledgements">D. Acknowledgements (Informative)</h2>

	<p>The Editors would like to give special thanks to the following contributors: David McNeil greatly improved the quality of the specification with detailed reviews and comments. Nuno Lopes and Eric Prud'hommeaux contributed to the design of the mapping from SQL data values to RDF literals. Eric also worked on the mechanism for SQL compatibility. Boris Villaz&oacute;n-Terrazas drew the diagrams throughout the text, and kept them up-to-date throughout many iterations.</p>

    <p>In addition, the Editors gratefully acknowledge contributions from: Marcelo Arenas, S&ouml;ren Auer, Samir Batla, Alexander de Leon, Orri Erling, Lee Feigenbaum, Enrico Franconi, Howard Greenblatt, Wolfgang Halb, Harry Halpin, Michael Hausenblas, Patrick Hayes, Ivan Herman, Nophadol Jekjantuk, Li Ma, Nan Ma, Ashok Malhotra, Ivan Mikhailov, Percy Enrique Rivera Salas, Juan Sequeda, Ben Szekely, Ted Thibodeau, and Edward Thomas.
    </p>

  </div>
</body>
</html>
