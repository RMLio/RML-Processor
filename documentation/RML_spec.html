
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8" />
  <title>RML: A Generic Mapping Language for RDF</title>
  <meta name=v"" content=  "" />
  <!-- <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css" /> -->
  <style type="text/css">
/*<![CDATA[*/
        body {
          padding: 2em 1em 2em 70px;
          margin: 0;
          font-family: sans-serif;
          color: black;
          background: white;
          background-position: top left;
          background-attachment: fixed;
          background-repeat: no-repeat;
        }

        h1, h2, h3, h4, h5, h6 { text-align: left }
        /* background should be transparent, but WebTV has a bug */
        h1, h2, h3 { color: #005A9C; background: white }
        h1 { font: 170% sans-serif }
        h2 { font: 140% sans-serif }
        h3 { font: 120% sans-serif }
        h4 { font: bold 100% sans-serif }
        h5 { font: italic 100% sans-serif }
        h6 { font: small-caps 100% sans-serif }

        dfn { color: navy; font-weight: bold; }
        pre { margin-left: 0; padding: 0 2em; }
        dt { margin-top: 0.8em; }
        th, td { padding: 0.3em 0.5em; }
        cite { font-style: normal }
        th { text-align: left; }
        h2, h3 { margin-top: 2em; }
        em.rfc2119 { text-transform: lowercase; font-variant: small-caps; font-style: normal; }
        
        table.term-index th code { font-weight: normal; }
        table.term-index th, table.term-index td { padding: 0.1em 0.5em; }
        .issue { background-color: #fdd; border: 1px solid #800; margin: 1em 0em; padding: 1em; page-break-inside: avoid ; font-style: italic; }
        .issue a.tracker { font-style: normal; font-weight: bold; }
        .note { background: #e2fff0; border: 2px solid #cff6d9; margin: 1em 0em 0em; padding: 1em; }
        .note:before { background: #fff; border: 1px solid #cff6d9; content: "Note"; display: block; font-weight: bold; margin: -1.5em 0 0.5em 0; padding: 0.2em 0.8em; width: 2.5em; }
        .ex-data, table.ex-data th, table.ex-data td { background: #cee; border: 1px solid #acc; }
        table.ex-data { border-collapse: collapse; margin-bottom: 1.5em; }
        table.ex-data caption, table.ex-data th, table.ex-data td { font-family: monospace; }
        table.ex-data caption, table.ex-data th { font-size: 125%; }
        table.ex-data caption { font-weight: bold; }
        table.ex-data th small, table.ex-data caption small { display: block; font-size: 65%; font-weight: normal; }
        pre.vocab, pre.ex-mapping, pre.ex-output, pre.ex-sql { margin-top: 1.5em; padding: 1em; }
        pre.vocab:before, pre.ex-mapping:before, pre.ex-output:before, pre.ex-sql:before { background: white; display: block; font-family: sans-serif; font-size: 90%; margin: -1.7em 0 0.5em 0; padding: 0.2em 0.4em; }
        pre.vocab { background: #d4dddd; }
        pre.vocab, pre.vocab:before { border: 1px solid #bbb; }
        pre.vocab:before { color: #888; content: "RML vocabulary definition"; width: 13em; }
        pre.ex-mapping, pre.ex-sql { background: #eeb; }
        pre.ex-mapping, pre.ex-mapping:before, pre.ex-sql, pre.ex-sql:before { border: 1px solid #cc9; }
        pre.ex-mapping:before { color: #996; content: "Example RML mapping"; width: 12em; }
        pre.ex-sql:before { color: #996; content: "Example query"; width: 9em; }
        .ex-output { background: #cfc; }
        .ex-output, .ex-output:before, .ex-output th, .ex-output td { border: 1px solid #aca; }
        pre.ex-output:before { color: #797; content: "Example output data"; width: 9.5em; }
        .toc ul { list-style-type: none; }
        .toc > li { font-weight: bold; margin-bottom: 0.8em; }
        .toc li li { font-weight: normal; }
  /*]]>*/
  </style>
</head>

<body>
  <div class="head">

    <h1><a name="title" id="title"></a>RML: A Generic Mapping Language for RDF</h1>

    <dl>
      <dt>This version:</dt> 
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd> 

      <dt>Latest version:</dt>
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd>

      <dt>Previous version:</dt>
      <dd><a href="http://mmlab.ugent.be/rml_spec.html">http://mmlab.ugent.be/rml_spec.html</a></dd>

      <dt>Editors:</dt>
      <dd>Anastasia Dimou</dd>
      <dd>Miel Vander Sande</dd>
    </dl>

    <p class="copyright"><a href="">Copyright</a> &copy; 2013 <sup>&reg;</sup>
  </div>
  <hr />


  <h2><a name="abstract" id="abstract"></a>Abstract</h2>

  <p>This document describes RML, a generic mapping language, based on and extending R2RML.
     R2RML is the W3C standard to express customized mappings from relational databases to RDF.
     RML extends R2RML to support data in other structured formats, too. 
     RML is a lnaguage for expressing customized mappings from data in structured formats to RDF datasets. 
     Such mappings provide the ability to view existing data in the RDF data model described using the mapping author's choice of vocabulary. 
     RML follows exactly the same syntax as R2RML; therefore, RML mappings are themselves RDF graphs and written down in Turtle syntax. 
  </p>

  
  <div class="toc">
    <h2><a name="contents" id="contents"></a>Table of Contents</h2>

<ul class="toc">
  <li><a href="#introduction">Introduction</a>
  <ul>
    <li><a href="#conventions">Document Conventions</a></li>
  </ul></li>
  <li><a href="#overview">RML Overview and Example (Informative)</a>
  <li><a href="#terminology">RDF Terminology (Informative)</a></li>
  <li><a href="#index">Index of RML Vocabulary Terms (Informative)</a>
  <ul>
    <li><a href="#class-index">Classes</a></li>
    <li><a href="#property-index">Properties</a></li>
    <li><a href="#other-index">Other Terms</a></li>
  </ul></li>
  <li><a href="#references">References</a></li>
  <li><a href="#acknowledgements"Acknowledgements (Informative)</a></li>
</ul>

</div>

  <hr />

  <div class="body">
    <h2><a name="introduction" id="introduction"></a>Introduction</h2>

    <p>This document describes RML, a language for expressing customized mappings
    from data in structured formats (databases and CSV, TSV, XML and JSON files) to RDF datasets. 
    Such mappings describe how existing data can be represented using the RDF data model.</p>

    <p>RML is based on and extends <cite>
      <a class="norm" href="http://www.w3.org/TR/r2rml/">R2RML</a></cite> [<cite><a href="#R2RML">R2RML</a></cite>].
    R2RML is defined to express customized mappings only from relational databases to RDF datasets. </p>

    <p>An RML mapping is not tailored to a specific database schema as an R2RML mapping, but can be defined for data in any other structure format (CSV, TSV, XML, JSON). 
      The input to an RML mapping can be any source file - currently in a structured format or a database. 
      The output is an RDF dataset that uses predicates and types from the target vocabulary. </p>

    <p>RML follows the same syntax as R2RML; therefore they are expressed as RDF graphs and written down in
    <cite><a class="norm" href="http://www.w3.org/TR/turtle/">Turtle syntax</a></cite> [<cite><a href="#TURTLE">TURTLE</a></cite>].</p>

    <h3 id="vocabulary">Mapping Graphs and the RML Vocabulary</h3>
    <p>The RML vocabulary namespace is <code>http://mmlab.be/ns/rml#</code> 
      <pre><strong><a href="http://www.w3.org/ns/r2rml#">http://mmlab.be/ns/rml#</a></strong></pre>
    </p>
    <p>The RML vocabulary preferred prefix is the <code>rml:</code> </p>

    <p>An RML mapping defines a mapping from any data in a structured source format to RDF. 
      It consists of one or more triples maps</a>.</p>

    <p>The input to an RML mapping is called source file.</p>

    <p>The RML vocabulary consists of the RML specific defined classes but also includes all the R2RML classes</p>

    <ul>
      <li><code>rr:TriplesMap</code> is the class of triples maps as defined by R2RML.</li>
      <li><code>rml:LogicalSource</code> is the class of logical sources. 
        It has two subclasses:
        <ul>
          <li><code>rml:RMLView</code> is the class of RML views</a>. R2RML's <code>rr:R2RMLView</code> is a subclass of <code>rml:RMLView</code></li>
          <li><code>rml:BaseSource</code> is the class of SQL base tables or views</a>. R2RML's <code>rr:BaseTableOrView</code> is a subclass of <code>rml:BaseSource</code></li>
        </ul>
      </li>
      <li><code>rr:TermMap</code> is the class of term maps, as defined by R2RML. 
        It has four subclasses:
        <ul>
          <li><code>rr:SubjectMap</code> is the class of subject maps.</li>
          <li><code>rr:PredicateMap</code> is the class of predicate maps.</li>
          <li><code>rr:ObjectMap</code> is the class of object maps.</li>
          <li><code>rr:GraphMap</code> is the class of graph maps.</li>
        </ul>
      </li>
      <li><code>rr:PredicateObjectMap</code> is the class of predicate-object maps.</li>
      <li><code>rr:RefObjectMap</code> is the class of referencing object maps.</li>
      <li><code>rr:Join</code> is the class of join conditions.</li>
      <li><code>rml:QueryLanguage</code> is the class of supported query languages.</li>
    </ul>

    <h3 id="conventions">Document Conventions</h3>

    <p>In this document, examples assume the following namespace prefix bindings unless otherwise stated:</p>

    <table rules="all" summary="list of prefixes used in the document">
      <tr>
        <th>Prefix</th>

        <th>IRI</th>
      </tr>

      <tr>
        <td><code>rml:</code></td>

        <td><code>http://mmlab.be/ns/rml#</code></td>
      </tr>

      <tr>
        <td><code>ql:</code></td>

        <td><code>http://mmlab.be/ns/ql#</code></td>
      </tr>

      <tr>
        <td><code>rr:</code></td>

        <td><code>http://www.w3.org/ns/r2rml#</code></td>
      </tr>

      <tr>
        <td><code>rdf:</code></td>

        <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
      </tr>

      <tr>
        <td><code>rdfs:</code></td>

        <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
      </tr>

      <tr>
        <td><code>xsd:</code></td>

        <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
      </tr>

      <tr>
        <td><code>ex:</code></td>

        <td><code>http://example.com/ns#</code></td>
      </tr>
    </table>

    <p>Gray boxes contain RDFS definitions of RML vocabulary terms:</p>
    <pre class="vocab">
      # This box contains RDFS definitions of RML vocabulary terms
    </pre>

    <p>Yellow boxes contain example fragments of RML mappings in Turtle syntax:</p>
    <pre class="ex-mapping">
      # This box contains example RML mappings
    </pre>

    <p>Blue tables contain example input into an RML mapping:</p>
    <table class="ex-data">
        <caption>input</caption>
        <tr>
          <td>
            #This box contains example input
          </d>
        </tr>
      </table>

    <p>Green boxes contain example output:</p>
    <pre class="ex-output">
      # This box contains example output RDF triples or fragments
    </pre>


    <h2 id="overview">RML Overview and Example (Informative)</h2>

    <p>An RML mapping refers to logical sources to retrieve data from the input file or database. 
      A logical source extends R2RML's logical Table. A logical source can be one of the following:</p>
    <ol>
      <li>A base source (A/N any input file or base table),</li>
      <li>a view (A/N in case of databases), or</li>
      <li>a view resulted from a valid query (called an RML view).</li>
    </ol>

    <h3 id="example-input-database">Example Input</h3>

    <table class="ex-data" id="">
        <caption>Airport.csv - CSV file</caption>
        <tr>
          <td>
            id, city, bus, latitude, longitude <br/>
            6523, Brussels, 25, 50.901389, 4.484444
          </d>
        </tr>
      </table>

      <table class="ex-data">
        <caption>Transport.xml - XML file</caption>
        <tr>
          <td>
            <span>
              &#60;transport&#62; <br/>
              &nbsp; &#60;bus id=“25”&#62; <br/>
              &nbsp; &nbsp; &#60;route&#62; <br/>
              &nbsp; &nbsp; &nbsp; &#60;stop id=“645”&#62; <br/>
              &nbsp; &nbsp; &nbsp; &nbsp; Int. Airport <br/>
              &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
              &nbsp; &nbsp; &nbsp; &#60;stop id=“651”&#62; <br/>
              &nbsp; &nbsp; &nbsp; &nbsp; Conference center <br/>
              &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
              &nbsp; &nbsp; &#60;/route&#62; <br/>
              &nbsp; &#60;/bus&#62; <br/>
              &#60;/transport&#62;
            </span>
          </d>
        </tr>
      </table>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP">
        <caption>Venue.json - JSON file</caption>
        <tr>
          <td>
            <span>
              { <br/>
                &nbsp; "venue": <br/>
                &nbsp; &nbsp; { <br/>
                &nbsp; &nbsp; &nbsp; "latitude": "51.0500000", <br/>
                &nbsp; &nbsp; &nbsp; "longitude": "3.7166700" <br/>
                &nbsp; &nbsp; }, <br/>
                &nbsp; &nbsp; "location": <br/>
                &nbsp; &nbsp; &nbsp; { <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "continent": "EU", <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "country": "BE", <br/>
                &nbsp; &nbsp; &nbsp; &nbsp; "city": "Brussels" <br/>
                &nbsp; &nbsp; &nbsp; } <br/>
                }     
            </span>
          </d>
        </tr>
      </table>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#AirportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName “http://www.example.com/Airport.csv”
            ];
            rr:subjectMap 
            [
              rr:template “http://airport.example.com/{id}”;
              rr:class transit:Stop 
            ];

          rr:predicateObjectMap 
          [
            rr:predicate transit:route;
            rr:objectMap 
            [ 
              &lt;#TransportMapping&gt;
                rr:joinCondition 
                [
                  rr:child “bus”;
                  rr:parent “/transport/bus@id” 
                ]
            ]
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:location;
            rr:objectMap 
            [ 
              &lt;#VenueMapping&gt;
              rr:joinCondition 
              [
                rr:child “city”;
                rr:parent “$.location.city”
              ]
            ]
          ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#TransportMapping&gt;
          rr:subjectMap 
          [ 
            rr:template “http://trans.example.com/{/transport/bus@id}”;
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector “/transport/bus/route/stop@id”;
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector “/transport/bus/route/stop”
            ]
          ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#LocationMapping&gt;
          rr:subjectMap 
          [
            rr:template http://loc.example.com/latlong/{$.venue.latitude},{$.venue.longitude}
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap “$.venue.latitude” 
          ]; 

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap “$.venue.longitude” 
          ] 
        ].
      </pre>

      <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.

        &lt;#VenueMapping&gt;
          rml:logicalSource 
          [
            rml:name “http://www.example.com/Venue.json”;
            rml:language ql:JSONPath 
          ];
          rr:subjectMap 
          [
            rr:template “http://loc.example.com/city/{$.location.city}”;
            rr:class schema:City;
          ];
          rr:predicateObjectMap 
          [
            rr:predicate geo:location;
            rr:objectMap &lt;#LocationMapping&gt; 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate gn:countryCode;
            rr:objectMap “$.location.country” 
          ]
          rr:predicateObjectMap 
          [
            rr:predicate geosp:onContinent;
            rr:objectMap “$.location.continent” 
          ].
      </pre>

    <p>The desired RDF triples to be produced from this database are as follows:</p>

    <pre class="ex-output">
      for Venue.json <br/>
        &lt;http://loc.example.com/city/Brussels&gt; geo:location &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt;.
        &lt;http://loc.example.com/city/Brussels&gt; gn:countryCode "BE".
        &lt;http://loc.example.com/city/Brussels&gt; geosp:onContinent "Europe".

        &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt; wgs84_pos:lat "51.0500000".
        &lt;http://loc.example.com/latlong/51.0500000,3.7166700&gt; wgs84_pos:long "3.7166700".
    </pre>

    <h3 id="example-simple">Example: Mapping a CSV file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding CSV file. 
      <br/>
      RML mappings for CSV files follow exactly the same syntax as in R2RML to refer to the CSV's records.
      <br/>
      It is considered a correspondence of CSV records, delimited by a line break (CRLF), to databases' rows.</p>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP">
        <caption>Airport.csv - CSV file</caption>
        <tr>
          <td>
            id, stop, latitude, longitude <br/>
            6523, 25, 50.901389, 4.484444
          </d>
        </tr>
      </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.

        &lt;#AirportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Airport.csv" ;
              rml:iterator "row"
            ];
          rr:subjectMap 
            [
              rr:template "http://airport.example.com/{id}";
              rr:class transit:Stop 
            ];

          rr:predicateObjectMap 
          [
            rr:predicate transit:route;
            rr:objectMap 
            [
              rml:selector "stop";
              rr:datatype xsd:int 
            ]
          ];

          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap "latitude" 
          ];
            
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap "longitude" 
          ].
      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#&gt;.
      <br/>
      &lt;http://airport.example.com/6523&gt; rdf:type transit:Stop.
      &lt;http://airport.example.com/6523&gt; transit:route "25"^^xsd:int.
      &lt;http://airport.example.com/6523&gt; wgs84_pos:lat "50.901389".
      &lt;http://airport.example.com/6523&gt; wgs84_pos:long "4.484444".
    </pre>


    <h3 id="example-r2rml-view">Example: Mapping an XML file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding XML file. <br/>
      RML mappings for XML files follow the same syntax as in R2RML. <br/>
      The references to the XML elements follow the syntax of the query language specified at the logical source. <br/>
      A/N XPath is the supported/preferred/default query language for XML files. 
    </p>

    <table class="ex-data">
      <caption>Transport.xml - XML file</caption>
      <tr>
        <td>
          <span>
            &#60;transport&#62; <br/>
            &nbsp; &#60;bus id=“25”&#62; <br/>
            &nbsp; &nbsp; &#60;route&#62; <br/>
            &nbsp; &nbsp; &nbsp; &#60;stop id=“645”&#62; <br/>
            &nbsp; &nbsp; &nbsp; &nbsp; International Airport <br/>
            &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
            &nbsp; &nbsp; &nbsp; &#60;stop id=“651”&#62; <br/>
            &nbsp; &nbsp; &nbsp; &nbsp; Conference center <br/>
            &nbsp; &nbsp; &nbsp; &#60;/stop&#62; <br/>
            &nbsp; &nbsp; &#60;/route&#62; <br/>
            &nbsp; &#60;/bus&#62; <br/>
            &#60;/transport&#62;
          </span>
        </d>
      </tr>
    </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

        &lt;#TransportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Transport.xml" ;
              rml:iterator "/transport/bus";
              rml:language ql:XPath;
            ];
          rr:subjectMap 
          [ 
            rr:template "http://trans.example.com/{/transport/bus@id}";
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop@id";
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop"
            ]
          ].
      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

      &lt;http://trans.example.com/25&gt; rdf:type transit:Stop.
      &lt;http://trans.example.com/25&gt; transit:stop "645"^^xsd:int.
      &lt;http://trans.example.com/25&gt; rdfs:label "International Airport".
      &lt;http://trans.example.com/25&gt; transit:stop "651"^^xsd:int.
      &lt;http://trans.example.com/25&gt; rdfs:label "Conference center".
    </pre>

    <h3 id="example-r2rml-view">Example: Mapping a JSON file</h3>

    <p>The following RML mapping document produces the desired triples from the corresponding JSON file. <br/>
      RML mappings for JSON files follow the same syntax as in R2RML. <br/>
      The references to the JSON objects follow the syntax of the query language specified at the logical source. <br/>
      A/N JSONPath is the preferred/supported query language for JSON files. 
    </p>

    <table class="ex-data">
      <caption>Venue.json - JSON file</caption>
      <tr>
        <td>
          <span>
              { <br/>
              &nbsp; "venue": <br/>
              &nbsp; { <br/>
              &nbsp; &nbsp; "latitude": "51.0500000", <br/>
              &nbsp; &nbsp; "longitude": "3.7166700" <br/>
              &nbsp; }, <br/>
              &nbsp; "location": <br/>
              &nbsp; { <br/>
              &nbsp; &nbsp; "continent": " EU", <br/>
              &nbsp; &nbsp; "country": "BE", <br/>
              &nbsp; &nbsp; "city": "Brussels" <br/>
              &nbsp;} <br/>
              } <br/>

          </span>
        </d>
      </tr>
    </table>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix schema: &lt;http://schema.org/&gt;.
        @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.
        @prefix gn: &lt;http://www.geonames.org/ontology#&gt;.

        &lt;#VenueMapping&gt;
          rml:logicalSource [
            rml:sourceName "http://www.example.com/files/Venue.json";
            rml:queryLanguage ql:JSONPath;
            rml:iterator "$"
          ];
          rr:subjectMap [
            rr:template "http://loc.example.com/city/{$.location.city}";
            rr:class schema:City 
          ];
    
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:lat;
            rr:objectMap "latitude" 
          ];
            
          rr:predicateObjectMap 
          [
            rr:predicate wgs84_pos:long;
            rr:objectMap "longitude" 
          ];

          rr:predicateObjectMap [
            rr:predicate gn:countryCode;
            rr:objectMap "$.location.country" 
          ].

      </pre>

    <pre class="ex-output">
      @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
      @prefix schema: &lt;http://schema.org/&gt;.
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
      @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
      @prefix wgs84_pos: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#lat&gt;.
      @prefix gn: &lt;http://www.geonames.org/ontology#&gt;.

      &lt;http://loc.example.com/city/25&gt; rdf:type schema:City.
      &lt;http://loc.example.com/city/25&gt; wgs84_pos:lat "50.901389".
      &lt;http://loc.example.com/city/25&gt; wgs84_pos:long "4.484444".
      &lt;http://loc.example.com/city/25&gt; gn:countryCode "BE".
    </pre>


    <h3 id="">Linking Two Files</h3>

    <p>
      To have more complete mappings, triples with the city where the airport is located needs to be generated.   
      Those triples' subject come from the <code>&lt;#AirportMapping&gt;</code> triples map, 
      while the objects come from the <code>&lt;#VenueMapping&gt;</code>.
    </p>

    <p>This can be achieved by adding another <code>rr:predicateObjectMap</code>
    to the <code>&lt;#AirportMapping&gt;</code>. This one uses the other triples map,
    <code>&lt;#VenueMapping&gt;</code>, as a parent triples map:</p>

    <pre class="ex-mapping">&lt;#AirportMapping&gt;
        rr:predicateObjectMap [
            rr:predicate ex:located;
            rr:objectMap [
                rr:parentTriplesMap &lt;#VenueMapping&gt;;
                rr:joinCondition [
                    rr:child "DEPTNO";
                    rr:parent "DEPTNO";
                ];
            ];
        ].</pre>

    <p>This performs a union between the CSV file and the JSON file. The objects will be generated from
    the subject map of the parent triples map, yielding the desired triple:</p>

    <pre class="ex-output">
      &lt;http://data.example.com/employee/7369&gt; ex:located &lt;http://data.example.com/department/10&gt;.
    </pre>

    <p>
      This completes the RML mapping document. An RML processor will generate the triples listed above from this mapping document.
    </p>


    <!-- <h3 id="">Many-to-Many Files</h3>

    <p>The following example will assume that a many-to-many relationship exists between 
    the extended versions of <a href="#ex_EMP_m2m"><code>EMP</code> table</a> and the <a
    href="#ex_DEPT_m2m"><code>DEPT</code> table</a> shown below. This
    many-to-many relationship is captured by the content of
    the <a href="#ex_EMP2DEPT"><code>EMP2DEPT</code> table</a>. The database consisting of
    the <code>EMP</code>, <code>DEPT</code>, and <code>EMP2DEPT</code> tables are shown below:</p>

      <table class="ex-data" summary="EMP table: sample data" id="ex_EMP_m2m">
        <caption>EMP</caption>
        <tr>
          <th>EMPNO <small>INTEGER PRIMARY KEY</small></th>
          <th>ENAME <small>VARCHAR(100)</small></th>
          <th>JOB <small>VARCHAR(20)</small></th>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>SMITH</code></td>
          <td><code>CLERK</code></td>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>SMITH</code></td>
          <td><code>NIGHTGUARD</code></td>
        </tr>
        <tr>
          <td><code>7400</code></td>
          <td><code>JONES</code></td>
          <td><code>ENGINEER</code></td>
        </tr>

      </table>

      <table class="ex-data" summary="DEPT table: sample data" id="ex_DEPT_m2m">
        <caption>DEPT</caption>
        <tr>
          <th>DEPTNO <small>INTEGER PRIMARY KEY</small></th>
          <th>DNAME <small>VARCHAR(30)</small></th>
          <th>LOC <small>VARCHAR(100)</small></th>
        </tr>
        <tr>
          <td><code>10</code></td>
          <td><code>APPSERVER</code></td>
          <td><code>NEW YORK</code></td>
        </tr>
        <tr>
          <td><code>20</code></td>
          <td><code>RESEARCH</code></td>
          <td><code>BOSTON</code></td>
        </tr>
      </table>

      <table class="ex-data" summary="EMP2DEPT table: sample data" id="ex_EMP2DEPT">
        <caption>EMP2DEPT <small>PRIMARY KEY (EMPNO, DEPTNO)</small></caption>
        <tr>
          <th>EMPNO <small>INTEGER REFERENCES EMP (EMPNO)</small></th>
          <th>DEPTNO <small>INTEGER REFERENCES DEPT (DEPTNO)</small></th>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>10</code></td>
        </tr>
        <tr>
          <td><code>7369</code></td>
          <td><code>20</code></td>
        </tr>
        <tr>
          <td><code>7400</code></td>
          <td><code>10</code></td>
        </tr>
      </table>

    <pre class="ex-output">
&lt;http://data.example.com/employee=7369/department=10&gt; 
    ex:employee   &lt;http://data.example.com/employee/7369&gt; ;
    ex:department &lt;http://data.example.com/department/10&gt; .

&lt;http://data.example.com/employee=7369/department=20&gt; 
    ex:employee &lt;http://data.example.com/employee/7369&gt; ;
    ex:department &lt;http://data.example.com/department/20&gt; .

&lt;http://data.example.com/employee=7400/department=10&gt; 
    ex:employee &lt;http://data.example.com/employee/7400&gt; ;
    ex:department &lt;http://data.example.com/department/10&gt; .
    </pre>

    <p>The following R2RML mapping will produce the desired triples listed above:</p>

    <pre class="ex-mapping">&lt;#TriplesMap3&gt;
    rr:logicalTable [ rr:tableName "EMP2DEPT" ];
    rr:subjectMap [ rr:template "http://data.example.com/employee={EMPNO}/department={DEPTNO}" ];
    rr:predicateObjectMap [
        rr:predicate ex:employee;
        rr:objectMap [ rr:template "http://data.example.com/employee/{EMPNO}" ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:department;
        rr:objectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ];
    ].
    </pre>


    <p>However, if one does <em>not</em> require that the subjects in
    the desired output uniquely identify the rows in the <a
    href="#ex_EMP2DEPT"><code>EMP2DEPT</code> table</a>, the desired output
    may look as follows: </p>

    <pre class="ex-output">
&lt;http://data.example.com/employee/7369&gt; 
    ex:department &lt;http://data.example.com/department/10&gt; ;
    ex:department &lt;http://data.example.com/department/20&gt; .

&lt;http://data.example.com/employee/7400&gt; 
    ex:department &lt;http://data.example.com/department/10&gt;.
    </pre>

    <p>The following R2RML mapping will produce the desired triples:</p>

    <pre class="ex-mapping">&lt;#TriplesMap3&gt;
    rr:logicalTable [ rr:tableName "EMP2DEPT" ];
    rr:subjectMap [
        rr:template "http://data.example.com/employee/{EMPNO}";
    ];
    rr:predicateObjectMap [
      rr:predicate ex:department;
      rr:objectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ];
    ].</pre>


    <h3 id="example-translationtable">2.7 Example: Translating database type codes to IRIs</h3>

    <p>Sometimes, database columns contain codes that need to be translated
    into IRIs, but a direct syntactic translation using string templates is not possible.
    For example, consider a <code>JOB</code> column in the <code>EMP</code>
    table with the following possible values, and IRIs corresponding to
    those database values in the RDF output:</p>

    <table>
    <tr><th>Value</th><th>Corresponding RDF IRI</th></tr>
    <tr><td><code>CLERK</code></td><td><code>http://data.example.com/roles/general-office</code></td></tr>
    <tr><td><code>NIGHTGUARD</code></td><td><code>http://data.example.com/roles/security</code></td></tr>
    <tr><td><code>ENGINEER</code></td><td><code>http://data.example.com/roles/engineering</code></td></tr>
    </table>

    <p>The IRIs are not found in the original database and therefore the mapping
    from database codes to IRIs has to be
    specified in the R2RML mapping. Such translations can be achieved using an
    “<a href="#dfn-r2rml-view">R2RML view</a>”. The view is defined based on a
    SQL query that computes the IRI based on the database value.
    SQL's <code>CASE</code> statement is convenient for this purpose.
    (Alternatively, one could define this view directly in the database.)</p>

    <pre class="ex-mapping">
&lt;#TriplesMap1&gt;
    rr:logicalTable [ rr:sqlQuery """

        SELECT EMP.*, (CASE JOB
            WHEN 'CLERK' THEN 'general-office'
            WHEN 'NIGHTGUARD' THEN 'security'
            WHEN 'ENGINEER' THEN 'engineering'
        END) ROLE FROM EMP

        """ ];
    rr:subjectMap [
        rr:template "http://data.example.com/employee/{EMPNO}";
    ];
    rr:predicateObjectMap [
        rr:predicate ex:role;
        rr:objectMap [ rr:template "http://data.example.com/roles/{ROLE}" ];
    ].
    </pre>

    <p>With the <a href="#example-input-database">example input database</a>,
    this mapping would yield the following triple:</p>

    <pre class="ex-output">
&lt;http://data.example.com/employee/7369&gt; ex:role &lt;http://data.example.com/roles/general-office&gt;.</pre>

    <p>Explicit typing of the resources in a mapping graph with
    <a href="#dfn-r2rml-classes">R2RML classes</a>
    is <em class="rfc2119">OPTIONAL</em> and
    has no effect on the behaviour of an
    <a href="#dfn-r2rml-processor">R2RML processor</a>.
    The <a href="#dfn-mapping-component">mapping component</a>
    represented by any given resource in a mapping graph is defined by the
    presence or absence of certain properties, as defined throughout this
    specification. A resource <em class="rfc2119">SHOULD NOT</em>
    be typed as an R2RML class if it does not meet the definition
    of that class.</p> -->



    <h2 id="logical-sources">Defining Logical Sources</h2>

    <p>A logical source is any source file that is mapped to RDF triples. A logical source is either</p>
    <ul>
      <li>a  Base Source, <code>rml:BaseSource</code></li>
      <li>an RML View, <code>rml:RMLView</code></li>
    </ul>

    <h3>Base Sources (<code>rml:sourceName</code>, <code>rml:iterator</code>, <code>rml:queryLanguage</code>)</h3>

    <p>A base source is a logical source pointing to a file or a database that contains the data to be mapped. <br/>
      At least the source Name, <code>rml:sourceName</code>, of the source file and its iterator, <code>rml:iterator</code>, should be defined. 
      <br/>
      A base source is represented by a resource that has:
      <ul>
        <li>exactly one source Name, <code>rml:sourceName</code> property,</li> 
        <li>exactly one iterator over the file <code>rml:iterator</code>.</li>
        <li>and zero or one query language property, <code>rml:queryLanguage</code>.</li> 
      </ul>
    </p>
    <p>
      The source name, <code>rml:sourceName</code>, locates the source file. <br/>
      The iterator, <code>rml:iterator</code>, defines the iteration loop used to map the data of the file or the database. <br/>
      The query language, <code>rml:queryLanguage</code>, defines the language that the iterator and the rest references to the source's data should be defined at.
    </p>

     <p>
      The logical source definition requires:
      <ul>
        <li>the <code>rml:sourceName</code> and the <code>rml:queryLanguage</code> to be defined and optionally the <code>rml:iterator</code>, in the case of databases.</li>
        <li>the logical source definition requires only the <code>rml:sourceName</code> and, optionally, the <code>rml:iterator</code> to be defined, in the case of CSV files.</li>
        <li>the logical source definition requires all three: the <code>rml:sourceName</code>, the <code>rml:iterator</code> and the <code>rml:queryLanguage</code> properties to be defined, in the case of XML and JSON files.</li>
      </ul>
    </p>

    <p>
      The value of the source Name, <code>rr:sourceName</code>, specifies the file or the database to be mapped.<br/>
      Its value can be either a string (A/N implicit reference to the file) or a valid URI of an existing file.
    </p>

    <p>
      As default iterator is considered the row. 
      <ul>
        <li>In the case of databases, CSV ot TSV source files, the value of the <code>rml:iterator</code>, if specified, is "row". </li>
        <li>In the case of XML and JSON source files, it is a valid reference to an element or an object respectively considering the query language specified. </li>
      </ul>
    </p>
    <p>
      The query language,<code>rml:queryLanguage</code>, defines the query language used to refer to the elements of the source file (by default SQL2008 for databases, XPath for XML and JSONPath for JSON files). The query language must be specified in the case of databases and XML and JSON files.
    </p>

    <h4>Examples</h4>

    <p>The following example shows a logical source specified for a CSV file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Airport.csv"
              rml:iterator "row"
            ].
        </pre>
    </p>
    <p>The following example shows a logical source specified for an XML file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
          [
            rml:sourceName "http://www.example.com/Transport.xml" ;
            rml:queryLanguage ql:XPath;
            rml:iterator "/transport/bus";
          ].
      </pre>
    </p>
    <p>The following example shows a logical source specified for a JSON file.</p>
      <pre class="ex-mapping">
        [] rml:logicalSource 
          [
            rml:sourceName "http://www.example.com/files/Venue.json";
            rml:queryLanguage ql:JSONPath;
            rml:iterator "$.city"
          ].
      </pre>
    </p>

    <!-- <p>A <dfn id="">schema-qualified name</dfn>
    is a sequence of one, two or three valid
    <a href="#dfn-sql-identifier">SQL identifiers</a>, separated
    by the dot character (“<code>.</code>”). The three identifiers
    name, respectively, a catalog, a schema, and a table or view.
    If no catalog or schema is specified, then the
    <a href="#dfn-default-catalog">default catalog</a> and
    <a href="#dfn-default-schema">default schema</a> of the
    <a href="#dfn-sql-connection">SQL connection</a> are assumed.</p>

    <p>The <a href="#dfn-effective-sql-query">effective SQL query</a>
    of a <a href="#dfn-sql-base-table-or-view">SQL base table or view</a> is:</p> 

    <pre>SELECT * FROM <em>{table}</em></pre>
    <p>with <code><em>{table}</em></code>
    replaced with the
    <a href="#dfn-table-or-view-name">table or view name</a>.</p> -->

    <h3>RML Views (<code>rml:sourceName</code>, <code>rml:query</code>, <code>rml:queryLanguage</code>)</h3>

    <p>An RML view is a <a href="#logical-source">logical source</a> 
      whose contents are the result of executing a query against the logical source specified. 
      It is represented by a resource that has 
      <ul>
        <li>exactly one <code>rml:queryLanguage</code> property, 
          whose value is the URI (A/N or a string) of the query language specified.
        <li>one <code>rml:query</code> property, 
          whose value is a literal with a lexical form that is a valid query considering the query language specified.
        </li>
      </ul>
    </p>

    <!-- <p class="note">
    R2RML mappings sometimes require data transformation, computation,
    or filtering before
    generating triples from the database. This can be achieved by defining
    a SQL view in the <a href="#dfn-input-database">input database</a>
    and referring to it with
    <a href="#dfn-sql-base-table-or-view"><code>rr:tableName</code></a>.
    However, this approach
    may sometimes not be practical for lack of database privileges or other
    reasons. <a href="#dfn-r2rml-view">R2RML views</a>
    achieve the same effect without requiring changes to the
    input database.</p> -->

    <p class="note">
      An RML view is used when combinations or extracts of logical sources need to be mapped.. (A/N argue more on this)
    </p>

    <p>A query <code>rml:query</code> is a string with a lexical form that is a valid query considering the query language specified.
    (A/N) Argue more regarding possible limitations..</p>

    <p>A query <code>rml:query</code>, can serve one of the following scopes: 
      <ul>(A/N needs better way to express it..)
        <li>a valid query in the specified language (<code>rml:queryLanguage</code>) that tries to retrieve an extract of the data available in the corresponding file and ends up to an RML View</li>
        <li>a valid <i>query-like</i> definition that facilitates the iteration over the specified file and it is used with an <code>rml:logicalSource</code> definition</li>
      </ul>
    </p>

    <h3 id="reference">Reference</h3>
    <p>A reference <code>rml:reference</code> is used to refer to
      <ul>
        <li>a column in case of databases,</li>
        <li>a record in case of CSV files,</li> 
        <li>an element in case of XML documents,</li>
        <li>an object in case of a JSON file. </li>
      </ul>
      A reference must be a valid identifier, considering the query language (<code>rml:queryLanguage</code>) specified. 
    </p>


    <h2 id="triples-map">Mapping Logical Sources to RDF with Triples Maps</h2>

    <p>A triples map specifies a rule for translating 
      <ul>
        <li>each row of a database, </li> 
        <li>each record of a CSV file, </li>
        <li>each element of an XML file, </li>
        <li>each object of a JSON file, </li>
      </ul>
      to zero or more RDF triples.</li>
    </p>

    <!-- <p>The RDF triples generated from one row in the logical table all share the same subject.</p> -->

    <p>A triples map in RML is defined as a triples map in RML.<br/>
       A triples map is represented by a resource that references the following other resources:</p>

    <ul>
      <li>It must have exactly one <code>rr:logicalSource</code> property.
          Its value is a <a href="#logical-source">logical source</a>
          that specifies the file or the database to be mapped to triples.</li>

    <li>It must have exactly one <a href="#subject-map">subject map</a>
        that specifies how to generate a subject for each row/record/element/object of the
        logical source (database/CSV file/XML file/JSON file accordingly). It may be specified in two ways:
      <ol>
        <li>using the <code>rr:subjectMap</code> property, whose value must be the subject map, or</li>
        <li>using the constant shortcut property, <code>rr:subject</code>.</li>
      </ol>
    </li>

    <li>It may have zero or more <code>rr:predicateObjectMap</code> properties,
        whose values must be a <a href="#predicate-object-map">predicate-object maps</a>.
        <code>rr:predicateObjectMap</code> properties specify pairs of predicate maps and object maps that,
        together with the subjects generated by the subject map, may form one or more
        <a href="#rdf-triple">RDF triples</a> for each row/record/element/object of the (database/CSV file/XML file/JSON file respectively).</li>
    </ul>
    
    <p>The references of all <a href="#term-map">term maps</a> of a triples map (subject map, predicate maps, object maps, graph maps) must be references to rows/records/elements/objects that exist in the term map's <a href="#logical-table">logical source</a>.</p>

    <p>The following example shows a <a href="#triples-map">triples map</a> including 
        its logical source, the subject map, and two predicate-object maps for an XML file.
    </p>

    <pre class="ex-mapping">
        @prefix rr: &lt;http://www.w3.org/ns/r2rml#&gt;.
        @prefix rml: &lt;http://mmlab.be/ns/rml#&gt;.
        @prefix ex: &lt;http://example.com/ns#&gt;.
        @prefix ql: &lt;http://mmlab.be/ns/ql#&gt;.
        @prefix transit: &lt;http://vocab.org/transit/terms/&gt;.
        @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.
        @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

        &lt;#TransportMapping&gt;
          rml:logicalSource 
            [
              rml:sourceName "http://www.example.com/Transport.xml" ;
              rml:query "transport/bus";
              rml:language ql:XPath;
            ];
          rr:subjectMap 
          [ 
            rr:template "http://trans.example.com/{/transport/bus@id}";
            rr:class transit:Stop 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate transit:stop;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop@id";
              rr:datatype xsd:int 
            ] 
          ];
          rr:predicateObjectMap 
          [
            rr:predicate rdfs:label;
            rr:objectMap 
            [
              rml:selector "/transport/bus/route/stop"
            ]
          ].
      </pre>

    <h3 id="predicate-object-map">Creating Properties and Values with Predicate-Object Maps</h3>

    <p>A <span id="predicate-object-map">predicate-object map</span> is a function that creates one or more predicate-object pairs for
       each row/record/element/object of a <a href="#logical-source">logical source</a>. 
       It is used in conjunction with a <a href="#subject-map">subject map</a> to generate <a href="#rdf-triple">RDF triples</a> in a
       <a href="#triples-map">triples map</a>.
     </p>

    <p>A <a href="#predicate-object-map">predicate-object map</a> is represented by a resource that references the following other resources:</p>

    <ul>
      <li>
        <p>One or more <a href="#predicate-map">predicate maps</a>.
        Each of them may be specified in one of two ways:</p>
        <ol>
          <li>using the <code>rr:predicateMap</code> property, whose value must be a <a href="#predicate-map">predicate map</a>, or</li>
          <li>using the <a href="#constant-shortcut-property">constant shortcut property</a> <code>rr:predicate</code>.</li>
        </ol>
      </li>
    <li>
      <p>One or more <a href="#object-map">object maps</a> or <a href="#referencing-object-map">referencing object maps</a>.
      Each of them may be specified in one of two ways:</p>
      <ol>
        <li>using the <code>rr:objectMap</code> property, whose value must be either an
          <a href="#object-map">object map</a>, or a
          <a href="#referencing-object-map">referencing object map</a>.
        </li>
        <li>using the <a href="#constant-shortcut-property">constant shortcut property</a> <code>rr:object</code>.</li>
      </ol>
    </li>
    </ul>

    <p>Both <dfn id="predicate-map">predicate maps</dfn> and <dfn id="object-map">object maps</dfn> are <a href="#term-map">term maps</a>.</p>

    <h2 id="term-map">Creating RDF Terms with Term Maps</h2>

    <p>(A/N) unchanged compared to R2RML</p>

    <p>An <span id="rdf-term">RDF term</span> is either an <a href="#iri">IRI</a>, or a <a href="#blank-node">blank node</a>,
       or a <a href="#literal">literal</a>.
    </p>

    <p>
      A <span id="term-map">term map</span> is a function that generates an <a href="#rdf-term">RDF term</a> from a
      <a href="#logical-reference">logical reference</a>. The result of that function is known as the term map's
      <a href="#generated-rdf-term">generated RDF term</a>.
    </p>

    <p>Term maps are used to generate the subjects, predicates and objects of the <a href="#rdf-triple">RDF triples</a> 
      that are generated by a <a href="#triples-map">triples map</a>. 
      Consequently, there are several kinds of <a href="#dfn-term-map">term maps</a>, depending on where in the mapping they occur:
      <a href="#subject-map">subject maps</a>,
      <a href="#predicate-map">predicate maps</a>,
      <a href="#object-map">object maps</a> and
      <a href="#graph-map">graph maps</a>.
    </p>

    <p>A <a href="#term-map">term map</a> <dfn id="must">must</dfn> be exactly one of the following:</p>

    <ul>
      <li>a <a href="#constant-valued-term-map">constant-valued term map</a>,</li>
      <li>a <a href="#selector-valued-term-map">selector-valued term map</a>,</li>
      <li>a <a href="#template-valued-term-map">template-valued term map</a>.</li>
    </ul>

    <p>The <dfn id="reference">references</dfn> of a <a href="#term-map">term map</a> are 
        the set of <a href="#column-name">column names</a> referenced in the term map and depend on the type of term map.
    </p>

    <h3 id="constant">Constant RDF Terms (<code>rr:constant</code>)</h3>

    <p>(A/N) unchanged compared to R2RML</p>

    <p>A <dfn id="constant-valued-term-map">constant-valued term map</dfn> is a <a href="#dfn-term-map">term map</a> that ignores the <a href="#logical-reference">logical references</a> specified by the query (A/N as an iterator) and always generates the same RDF term. 
    <br/>  
    A constant-valued term map is represented by a
    resource that has exactly one <code>rr:constant</code> property.
    </p>

    <p>The <dfn id="constant-value">constant value</dfn> of a <a href="#constant-valued-term-map">constant-valued term map</a>
    is the RDF term that is the value of its <code>rr:constant</code> property.</p>

    <p>If the <a href="#constant-valued-term-map">constant-valued term map</a> is a <a href="#subject-map">subject map</a>,
    <a href="#predicate-map">predicate map</a> or <a href="#graph-map">graph map</a>, then its <a href="#constant-value">constant value</a>
    must be an <a href="#iri">IRI</a>.</p>

    <p>
      If the <a href="#constant-valued-term-map">constant-valued term map</a> is an <a href="#object-map">object map</a>, then its
      <a href="#constant-value">constant value</a> must be an <a href="#iri">IRI</a> or <a href="#literal">literal</a>.
    </p>

    <p>The <a href="#reference">references</a> of a <a href="#constant-valued-term-map">constant-valued term map</a> is the empty set.</p>

    <p>Constant-valued term maps can be expressed more concisely using the <dfn id="constant-shortcut-property">constant shortcut properties</dfn>
    <code>rr:subject</code>, <code>rr:predicate</code>, <code>rr:object</code> and <code>rr:graph</code>.
    Occurrences of these properties must be treated exactly as if the following triples were present in the mapping graph instead:</p>

    <table rules="all" summary="Constant shortcut properties and their replacements">
      <tr>
        <th>Triple involving constant shortcut property</th>
        <th>Replacement triples</th>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:subject <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:subjectMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:predicate <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:predicateMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:object <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:objectMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
      <tr>
        <td><code><em>?x</em> rr:graph <em>?y</em>.</code></td>
        <td><code><em>?x</em> rr:graphMap [ rr:constant <em>?y</em> ].</code></td>
      </tr>
    </table>

    <p>
      The following example shows a <a href="#predicate-object-map">predicate-object map</a> 
      that uses a constant-valued term map both for its predicate and for its object.
    </p>
    <pre class="ex-mapping">
      [] rr:predicateMap [ rr:constant rdf:type ];
         rr:objectMap [ rr:constant ex:Employee ].
    </pre>
    
    <p>If added to a <a href="#triples-map">triples map</a>,
    this predicate-object map would add the following triple to
    all resources <code>?x</code> generated by the triples map:</p>
    <pre class="ex-output">
      ?x rdf:type ex:Employee.
    </pre>

    <p>The following example uses
    <a href="#constant-shortcut-property">constant shortcut properties</a>
    and is equivalent to the example above:</p>

    <pre class="ex-mapping">
      [] rr:predicate rdf:type;
         rr:object ex:Employee.
    </pre>

    <h3 id="from-column">From a Selector (<code>rml:selector</code>)</h3>

    <p>A <dfn id="selector-valued-term-map">selector-valued term map</dfn>
    is a <a href="#term-map">term map</a> that is represented by
    a resource that has exactly one <code>rml:selector</code> property.</p>

    <p>The value of the <code>rml:selector</code> property must be a valid <a href="#selector">selector</a>. 
       The <dfn id="selector-value">selector value</dfn> of the term map is the data value of that column in a given 
       <a href="#logical-reference">logical reference</a>.
    </p>

    <p>The <a href="#iterator">iterator</a> of a <a href="#selector-valued-term-map">selector-valued term map</a>
    is the singleton set containing the value of the term map's <code>rml:selector</code> property.</p>

    <p>The following examples defines an <a href="#object-map">object map</a>that generates <a href="#literal">literals</a> for each different case of file formats.

    <h4>Selector for a database</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "DNAME" ].
    </pre>

    <h4>Selector for a CSV file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "name" ].
    </pre>

    <h4>Selector for an XML file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "/city/name" ].
    </pre>

    <h4>Selector for a JSON file</h4>
    <pre class="ex-mapping">
      [] rr:objectMap [ rr:column "$.city.name" ].
    </pre>

    <p>Using the sample specified in the beginning.</p>

    <h3 id="from-template">From a Template (<code>rr:template</code>)</h3>

    <p>A <dfn id="template-valued-term-map">template-valued term map</dfn> is a <a href="#term-map">term map</a> 
      that is represented by a resource that has exactly one <code>rr:template</code> property.
      The value of the <code>rr:template</code> property must be a valid <a href="#string-template">string template</a>.
    </p>

    <p>A <dfn id="string-template">string template</dfn> is a format string that can be used to build strings from multiple
    components. It can reference <a href="#column-name">column names</a> by enclosing them in curly braces (“<code>{</code>” and “<code>}</code>”).
    The following syntax rules apply to valid string templates:</p>

    <ul>
    <li>Pairs of unescaped curly braces must enclose valid <a href="#selector-name">selector names</a> according to the specified query language.</li>
    <li>Curly braces that do not enclose selector's names must be escaped by a backslash character (“<code>\</code>”). 
        This also applies to curly braces within column names.</li>
    <li>Backslash characters (“<code>\</code>”) must be escaped by preceding them with another backslash character, yielding “<code>\\</code>”.
    This also applies to backslashes within column names.</li>
    <li>There <em class="rfc2119">SHOULD</em> be at least one pair
    of unescaped curly braces.</li>
    <li>If a template contains multiple pairs of unescaped curly braces,
    then any pair should be separated from the next one
    by a <dfn id="safe-separator">safe separator</dfn>. This is any character or
    string that does not occur anywhere
    in any of the data values of either referenced column; or in the
    <a href="#iri-safe">IRI-safe versions</a> of the data values,
    if the <a href="#term-type">term type</a> is <code>rr:IRI</code>
    (see <a href="#note-safe-separators">note below</a>).</li>
    </ul>

    <p>The <dfn id="template-value">template value</dfn> of the term map for a given <a href="#dfn-logical-table-row">logical iterator</a>
    is determined as follows:</p>

    <ol>
      <li>Let <code><em>result</em></code> be the <a href="#string-template">template string</a></li>
      <li>For each pair of unescaped curly braces in <code><em>result</em></code>:
        <ol>
          <li>Let <code><em>value</em></code> be the data value of the selector whose name is enclosed in the curly braces</li>
          <li>If <code><em>value</em></code> is <code>NULL</code>, then return <code>NULL</code></li>
          <li>Let <code><em>value</em></code> be the <a href="#natural-rdf-lexical-form">natural RDF lexical form</a>
          corresponding to <code><em>value</em></code></li>
          <li>If the <a href="#term-type">term type</a> is <code>rr:IRI</code>, 
              then replace the pair of curly braces with an <a href="#iri-safe">IRI-safe version</a> of
              <code><em>value</em></code>; otherwise, replace the pair of curly braces with <code><em>value</em></code>
          </li>
        </ol>
      </li>
      <li>Return <code><em>result</em></code></li>
    </ol>
    <p>
      (A/N make sure this is fullfield)
      The <dfn id="iri-safe">IRI-safe version</dfn> of a string is obtained by applying the following transformation to any character
      that is not in the <cite><a class="norm" href="http://tools.ietf.org/html/rfc3987#section-2.2">
      <code>iunreserved</code> production</a></cite> in [<cite><a href="#RFC3987">RFC3987</a></cite>]:
    </p>

    <ol>
    <li>Convert the character to a sequence of one or more octets using <cite><a class="norm" href="http://tools.ietf.org/html/rfc3629">UTF-8</a></cite>
    [<cite><a href="#RFC3629">RFC3629</a></cite>]</li>
    <li><cite><a class="norm" href="http://tools.ietf.org/html/rfc3986#section-2.1">Percent-encode</a></cite>
    each octet [<cite><a href="#RFC3986">RFC3986</a></cite>]</li>
    </ol>

    <!-- <p>The following table shows examples of strings and their IRI-safe versions:</p>

    <table rules="all" id="example-iri-safe">
      <tr><th>String</th><th>IRI-safe version</th></tr>
      <tr><td>42</td><td>42</td></tr>
      <tr><td>Hello World!</td><td>Hello%20World%21</td></tr>
      <tr><td>2011-08-23T22:17:00Z</td><td>2011-08-23T22%3A17%3A00Z</td></tr>
      <tr><td>~A_17.1-2</td><td>~A_17.1-2</td></tr>
      <tr><td>葉篤正</td><td>葉篤正</td></tr>
    </table> 

    <p class="note">R2RML always performs percent-encoding when IRIs are
    generated from string templates. If IRIs need to be generated without
    percent-encoding, then <code>rr:column</code> should be used instead
    of <code>rr:template</code>, with an
    <a href="#dfn-r2rml-view">R2RML view</a> that performs the string
    concatenation.</p> -->

    <p class="note" id="note-safe-separators">
      (A/N look thoroughly into this)
      In the case of string templates
      that generate IRIs, any single character that is legal in an IRI, but percent-encoded in the <a href="#iri-safe">IRI-safe version</a> 
      of a data value, is a <a href="#safe-separator">safe separator</a>.
      This includes in particular the eleven <code>sub-delim</code> characters defined in
      [<cite><a href="#RFC3987">RFC3987</a></cite>]: <code>!$&amp;'()*+,;=</code>
    </p>

    <p>The <a href="#referenced-columns">referenced selectors</a> of a <a href="#template-valued-term-map">template-valued term map</a>
    is the set of <a href="#column-name">selectors</a> enclosed in unescaped curly braces in the <a href="#dfn-string-template">template string</a>.
    </p>

    <!-- <p>The following example defines a
    <a href="#subject-map">subject map</a> that generates
    <a href="#dfn-iri">IRIs</a> from the
    <code>DEPTNO</code> column of a logical table.</p>
    <pre class="ex-mapping">
[] rr:subjectMap [ rr:template "http://data.example.com/department/{DEPTNO}" ].</pre>

    <p>Using the sample row from the
    <a href="#ex_DEPT"><code>DEPT</code> table</a> as a logical table
    row, the <a href="#dfn-template-value">template value</a> of the subject map
    would be:</p>

    <pre class="ex-output">http://data.example.com/department/10</pre>

    <p>The following example shows how an <a href="#dfn-iri-safe">IRI-safe</a>
    template value is created:</p> -->
    <pre class="ex-mapping">
      [] rr:subjectMap [ rr:template "http://data.example.com/site/{LOC}" ].</pre>

    <!-- <p>Using the sample row from the
    <a href="#ex_DEPT"><code>DEPT</code> table</a> as a logical table
    row, the <a href="#dfn-template-value">template value</a> of the subject map
    would be:</p> -->

    <pre class="ex-output">http://data.example.com/site/NEW%20YORK</pre>

    <p>
      The space character is not in the <code>iunreserved</code> set,
      and therefore percent-encoding is applied to the character, yielding
      “<code>%20</code>”.
    </p>

    <p>The following example shows the use of backslash escapes in string templates. 
      The template will generate a fancy title such as</p>
      <pre>{{{ \o/ Hello World! \o/ }}}</pre>
      <p>from a string “<code>Hello World!</code>” in the <code>TITLE</code>
        column. By default, <code>rr:template</code> generates IRIs. Since
        the intention here is to create a literal instead,
        the <a href="#dfn-term-type">term type</a> has to be set.
      </p>
      <pre class="ex-mapping">
        [] rr:objectMap [
            rr:template "\\{\\{\\{ \\\\o/ {TITLE} \\\\o/ \\}\\}\\}";
            rr:termType rr:Literal;
        ].
      </pre>
      <p>Note that because <a class="norm" href="http://www.w3.org/TR/turtle/#string">
        backslashes need to be escaped by a second backslash in the Turtle syntax</a>
        [<cite><a href="#TURTLE">TURTLE</a></cite>],
        a double backslash is needed to escape each curly brace, and to get one literal backslash in the output one needs to write
        four backslashes in the template.
      </p>

      <h3 id="termtype">IRIs, Literal, Blank Nodes (<code>rr:termType</code>)</h3>
    <p>(A/N) unchanged compared to R2RML</p>
    <p>
      The <dfn id="term-type">term type</dfn> of a
      <a href="#selector-valued-term-map">selector-valued term map</a> or
      <a href="#template-valued-term-map">template-valued term map</a>
      determines the kind of <a href="#dfn-generated-rdf-term">generated RDF term</a>
      (<a href="#iri">IRIs</a>, <a href="#dfn-blank-node">blank nodes</a> or <a href="#dfn-literal">literals</a>).
    </p>

    <p>
      If the term map has an optional <code>rr:termType</code> property,
      then its <a href="#term-type">term type</a> is the value of that property.
       The value must be an IRI and must be one of the following options:</p>
      <ul>
        <li>If the term map is a <a href="#subject-map">subject map</a>:
          <code>rr:IRI</code> or <code>rr:BlankNode</code>
        </li>
        <li>If the term map is a <a href="#predicate-map">predicate map</a>:
          <code>rr:IRI</code>
        </li>
        <li>If the term map is an <a href="#object-map">object map</a>:
          <code>rr:IRI</code>, 
          <code>rr:BlankNode</code>, or 
          <code>rr:Literal</code>
        </li>
        <li>If the term map is a <a href="#graph-map">graph map</a>: 
          <code>rr:IRI</code>
        </li>
      </ul>

    <p>If the term map does not have a <code>rr:termType</code> property, then its <a href="#dfn-term-type">term type</a> is: </p>

    <ul>
      <li><code>rr:Literal</code>, if it is an <a href="#dfn-object-map">object map</a> and at least one of the following conditions is true:
        <ul>
          <li>It is a <a href="#column-valued-term-map">column-based term map</a>.</li>
          <li>It has a <code>rml:queryLanguage</code> property (and thus a
            <a href="#dfn-specified-language-tag">specified language tag</a>).
          </li>
          <li>It has a <code>rr:datatype</code> property (and thus a <a href="#specified-datatype">specified datatype</a>).</li>
        </ul>
      </li>
      <li><code>rr:IRI</code>, otherwise.</li>
    </ul>

    <p class="note">Term maps with term type <code>rr:IRI</code> cause <a href="#data-error">data errors</a> 
      if the value is not a valid <a href="#dfn-iri">IRI</a> (see <a href="#dfn-generated-rdf-term">generated RDF term</a> for details).
      Data values from the input database may require percent-encoding before they can be used in IRIs.
      <a href="#template-valued-term-map">Template-valued term maps</a> are a convenient way of percent-encoding data values.
    </p>

    <p class="note">
      <a href="#constant-valued-term-map">Constant-valued term maps</a>
      are not considered as having a <a href="#dfn-term-type">term type</a>,
      and specifying <code>rr:termType</code> on these term maps has no effect.
      The type of the generated RDF term is determined directly by the value of <code>rr:constant</code>: 
      If it is an IRI, then an IRI will be generated; if it is a literal, a literal will be
      generated.
    </p>
  </div>
</body>
</html>